Index: git/drivers/misc/Kconfig
===================================================================
--- git.orig/drivers/misc/Kconfig	2013-12-04 18:55:05.243964726 -0700
+++ git/drivers/misc/Kconfig	2013-12-04 18:55:08.191964756 -0700
@@ -549,6 +549,19 @@
 	  their requirements.
 
 	  If unsure, say N
+config VSC330X
+	tristate "Support VSC330X crosspoint switch"
+	help
+	  Say Y here if you have a VSC30X crosspoint switch IC on the I2C bus.
+	  To compile this driver as a module, choose M here: the
+	  module will be called vsc330x.
+
+config SI5338
+	tristate "Support Silicon Laboratories SI5338 Quad Clock Generator"
+	help
+	  Say Y here if you have a SI5338 cQuad Clock Generator IC on the I2C bus.
+	  To compile this driver as a module, choose M here: the
+	  module will be called si5338.
 
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
Index: git/drivers/misc/Makefile
===================================================================
--- git.orig/drivers/misc/Makefile	2013-12-04 18:55:05.243964726 -0700
+++ git/drivers/misc/Makefile	2013-12-04 18:55:08.191964756 -0700
@@ -55,3 +55,5 @@
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
 obj-$(CONFIG_XILINX_TRAFGEN)	+= xilinx_trafgen.o
+obj-$(CONFIG_VSC330X)	        += vsc330x.o
+obj-$(CONFIG_SI5338)	        += si5338.o
Index: git/drivers/misc/vsc330x.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/drivers/misc/vsc330x.c	2013-12-04 18:55:08.191964756 -0700
@@ -0,0 +1,872 @@
+/*!***************************************************************************
+ *! FILE NAME  : vsc330x.c
+ *! DESCRIPTION: control of the VSC3304 4x4 crosspoint switch
+ *! Copyright (C) 2013 Elphel, Inc.
+ *! -----------------------------------------------------------------------------**
+ *!
+ *!  This program is free software: you can redistribute it and/or modify
+ *!  it under the terms of the GNU General Public License as published by
+ *!  the Free Software Foundation, either version 3 of the License, or
+ *!  (at your option) any later version.
+ *!
+ *!  This program is distributed in the hope that it will be useful,
+ *!  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *!  GNU General Public License for more details.
+ *!
+ *!  You should have received a copy of the GNU General Public License
+ *!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/of.h>
+
+#define DRV_VERSION "1.0"
+/* TODO: Descriptions from vsc3312 - check differences */
+#define I2C_PAGE_CONNECTION        0x00	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding output (0..0xf) source
+					   (input number) bit 4 (+0x10) - turn output off, bits 3:0 - source */
+#define I2C_PAGE_INPUT_ISE         0x10	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding input (0..0xf)
+					   ISE (equalization): Bits 5:4 ISE short: 0 - off, 1 - minimal, 2 - moderate, 3 - maximal;
+					   bits 3:2 ISE medium, bits 1:0 ISE Long time constant */
+#define I2C_PAGE_INPUT_STATE       0x11	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding input (0..0xf) enable,
+					   polarity and termination (default 6)
+					   Bit 2 (+4) Terminate to VDD ( 0 - connect,  1 - do not connect) - dedicated (0..7) inputs only
+					   Bit 1 (+2) Input power (0 - on, 1 - off)
+					   Bit 0 (+1) Invert signal at input  */
+#define I2C_INPUT_STATE_DATA       0x04	/* terminated,enabled, not inverted */
+#define I2C_PAGE_INPUT_LOS         0x12	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding input (0..0xf)
+					   LOS (loss of signal) threshold
+					   Bits 2:0 - level in mV for dedicated(bidirectional) inputs: 0,1,6,7 - unused, 2 - 150(170),
+					   3 - 200(230), 4 - 250(280), 5 - 300(330) */
+#define I2C_PAGE_OUTPUT_PRE_LONG   0x20	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding output (0..0xf)
+					   long time constant pre-emphasis
+					   Bits 6:3 Pre-Emphasis level (0x0 - off, 0x1 - min, 0xf - max - 0..6dB), bits 2:0 - Pre-emphasis
+					   decay (0x0 - fastest, 0x7 - slowest) in 500..1500 ps range */
+#define I2C_PAGE_OUTPUT_PRE_SHORT  0x21	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding output (0..0xf)
+					   short time constant pre-emphasis
+					   Bits 6:3 Pre-Emphasis level (0x0 - off, 0x1 - min, 0xf - max - 0..6dB),
+					   bits 2:0 - Pre-emphasis decay (0x0 - fastest, 0x7 - slowest) in 30..500 ps range */
+#define I2C_PAGE_OUTPUT_LEVEL      0x22	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding output (0..0xf)
+					   short time constant pre-emphasis
+					   Bits 3:0 - peak-to-peak 0,1,0xe,0xf - unused, 0x2-405mV,0x3-425V,0x4-455mV,0x5-485mV,0x6-520mV,
+					   0x7-555mV,0x8-605mV,0x9-655mV,0xa-720mV,0xb-790mV,0xc-890mV,0xd-990mV (+3.3VDC required)
+					   bit 4 (+0x10) - for 8-15 used as inputs only: terminate inputs 8..15 to VDDIO-0.7V */
+#define I2C_PAGE_OUTPUT_STATE      0x23	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control corresponding output (0..0xf)
+					   OOB signaling and output polarity
+					   bits 4:1 - operation mode: 0xa  - inverted, 0x5 - normal, 0x0 - suppressed
+					   bit 0 - OOB control:     1 - enable LOS forwarding, 0 - ignore LOS */
+#define I2C_PAGE_CHANNEL_STATUS    0xf0	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf monitor corresponding input (0..0xf) LOS status
+					   bit 0 - LOS status: 1 - LOS detected (loss of signal), 0 - signal present (input has to be enabled,
+					   otherwise 0 is read)when reading from address 0x10 of this page:
+					   bit 0 - value of STAT0
+					   bit 1 - value of STAT1 */
+#define I2C_PAGE_STATUS0_CONFIGURE 0x80	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control selected input LOS to be OR-ed
+					   to STAT0 output pin (and bit)
+					   bit 0 : 1 - OR this input channel LOS status to STAT0 */
+#define I2C_PAGE_STATUS1_CONFIGURE 0x81	/* When written to I2C_CURRENT_PAGE, makes registers 0..0xf control selected input LOS to be OR-ed
+					   to STAT1 output pin (and bit)
+					   bit 0 : 1 - OR this input channel LOS status to STAT1 */
+#define I2C_PAGE_STATUS_READ       0xf0	/* Read only from reg=0x10: bit 0 - status0, bit 1 - status 1 */
+
+#define I2C_GLOBAL_CONNECTION      0x50	/* Bit 4 (+0x10) - disable all outputs, bits 3:0 - input number to connect to all outputs */
+#define I2C_GLOBAL_INPUT_ISE       0x51	/* Bits 5:4 ISE short: 0 - off, 1 - minimal, 2 - moderate, 3 - maximal; bits 3:2 ISE medium,
+					   bits 1:0 ISE Long time constant */
+#define I2C_GLOBAL_INPUT_STATE     0x52	/* Bit 2 (+4) - terminate input to VDD (0..7 only) 0-connect, 1 Normal;
+					   Bit 1 (+2) Input power off (0 - On, 1 - Off) bit0 (+1): Input polarity: 1 - inverted, 0 - normal  */
+#define I2C_GLOBAL_INPUT_LOS       0x53	/* Bits 2:0 - level in mV for dedicated(bidirectional) inputs: 0,1,6,7 - unused, 2 - 150(170),
+					   3 - 200(230), 4 - 250(280), 5 - 300(330) */
+#define I2C_GLOBAL_OUTPUT_PRE_LONG 0x54	/* Bits 6:3 Pre-Emphasis level (0x0 - off, 0x1 - min, 0xf - max - 0..6dB),
+					   bits 2:0 - Pre-emphasis decay (0x0 - fastest, 0x7 - slowest) in 500..1500 ps range */
+#define I2C_GLOBAL_OUTPUT_PRE_SHORT 0x55 /* Bits 6:3 Pre-Emphasis level (0x0 - off, 0x1 - min, 0xf - max - 0..6dB),
+					   bits 2:0 - Pre-emphasis decay (0x0 - fastest, 0x7 - slowest) in 30..500 ps range */
+#define I2C_GLOBAL_OUTPUT_LEVEL    0x56	/* Bits 3:0 - peak-to-peak 0,1,0xe,0xf - unused,0x2-405mV,0x3-425V,0x4-455mV,0x5-485mV,
+					   0x6-520mV,0x7-555mV,0x8-605mV,0x9-655mV,0xa-720mV,0xb-790mV,0xc-890mV,0xd-990mV (+3.3VDC required)
+					   bit 4 (+0x10) terminate inputs 8..15 to VDDIO-0.7V */
+#define I2C_GLOBAL_OUTPUT_STATE    0x57	/* +1 (bit 0) - LOS, +0x15 - inverted, 0xa0 - normal, +0 - "Common mode" ? */
+#define I2C_GLOBAL_OUTPUT_STATE_DATA 0x0b /* No inversion, enable OOB forwarding on all channels */
+#define I2C_GLOBAL_STATUS0         0x58	/* Bit 0 - selected for Status0 chanel LOS on from all channels */
+#define I2C_GLOBAL_STATUS1         0x59	/* Bit 0 - selected for Status1 chanel LOS on from all channels */
+#define I2C_CORE_CONFIGURATION     0x75
+#define I2C_CORE_CONFIGURATION_DATA  0x18	/* default 0x18 - 0x10 - leftEn, 0x8 - rightEn, 0x4 - DNU, 0x2 - BufferForceOn, 0x1 - Config polarity */
+#define I2C_CORE_CONFIGURATION_DATAF 0x19	/* default with inverted Config polarity (freeze update) */
+#define I2C_SLAVE_ADDRESS          0x78	/* programmed only, not hardwired */
+#define I2C_INTERFACE_MODE         0x79
+#define I2C_INTERFACE_MODE_DATA    0x02	/* i2c (1 - 4-wire)  */
+#define I2C_SOFTWARE_RESET         0x7a
+#define I2C_SOFTWARE_RESET_DATA    0x10	/* to reset, 0 - normal  */
+#define I2C_CURRENT_PAGE           0x7f
+#define PORT_PEFIX                 "port_"
+#define ALL_PORTS                  "all"
+#define MAX_PORTS                   16
+#define I2C_PAGE_GLOBAL             -1 /* does not use paging access */
+
+#define SYSFS_PERMISSIONS         0644 /* default permissions for sysfs files */
+#define SYSFS_READONLY            0444
+#define SYSFS_WRITEONLY           0222
+
+static const char port_names[][8]={
+		PORT_PEFIX "00",PORT_PEFIX "01",PORT_PEFIX "02",PORT_PEFIX "03",PORT_PEFIX "04",
+		PORT_PEFIX "05",PORT_PEFIX "06",PORT_PEFIX "07",PORT_PEFIX "08",PORT_PEFIX "09",
+		PORT_PEFIX "10",PORT_PEFIX "11",PORT_PEFIX "12",PORT_PEFIX "13",PORT_PEFIX "14",
+		PORT_PEFIX "15",PORT_PEFIX "16",PORT_PEFIX "17",PORT_PEFIX "18",PORT_PEFIX "19",
+		PORT_PEFIX "20",PORT_PEFIX "21",PORT_PEFIX "22",PORT_PEFIX "23",PORT_PEFIX "24",
+		PORT_PEFIX "25",PORT_PEFIX "26",PORT_PEFIX "27",PORT_PEFIX "28",PORT_PEFIX "29",
+		PORT_PEFIX "30",PORT_PEFIX "31"};
+
+static const struct i2c_device_id vsc330x_id[] = {
+	{ "vsc3304", 0 },
+	{ "vsc3308", 1 },
+	{ "vsc3312", 2 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, vsc3304_id);
+
+struct vsc330x_data_t {
+	int  address_mode_data; // vsc3304 needs 6 to be written, otherwise weird modification  of bit 3
+	int  last_page;
+	u32 in_ports;
+	u32 out_ports;
+};
+
+static const struct vsc330x_data_t vsc330x_data[] = {
+		{.address_mode_data=6,
+				.in_ports=0xff00, .out_ports=0xff00}, /* 3304 - all ports I/O shared*/
+		{.address_mode_data=-1, // No data, unknown if it is needed for 3308
+				.in_ports=0x00ff, .out_ports=0x00ff}, /* 3308 - no ports I/O shared */
+		{.address_mode_data=-1, // No data, unknown if it is needed for 3308
+				.in_ports=0xffff, .out_ports=0xffff} /* 3312 - some ports I/O shared*/
+};
+static int init_device(struct i2c_client *client);
+static int read_reg(struct i2c_client *client, u8 reg);
+static int write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int read_field(struct i2c_client *client, u8 reg, int ls_bit_num, int width);
+static int read_page_field(struct i2c_client *client, int page, u8 reg, int ls_bit_num, int width);
+static int write_field(struct i2c_client *client, u8 reg, u8 val, int ls_bit_num, int width);
+static int write_page_field(struct i2c_client *client, int page, u8 reg, u8 val, int ls_bit_num, int width);
+static ssize_t field_show(struct device *dev, struct device_attribute *attr, char *buf,
+		int page, int ls_bit_num, int width);
+static ssize_t field_show_reg(struct device *dev, char *buf, int page, int reg, int ls_bit_num, int width);
+static ssize_t field_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,
+		int page, int ls_bit_num, int width);
+static ssize_t field_store_reg(struct device *dev, const char *buf, size_t count,
+		int page, int reg, int ls_bit_num, int width);
+static ssize_t connection_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t connection_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_ISE_short_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_ISE_short_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_ISE_medium_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_ISE_medium_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_ISE_long_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_ISE_long_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_state_off_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_state_off_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_state_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_state_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_LOS_threshold_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_LOS_threshold_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_PRE_long_level_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_PRE_long_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_PRE_long_decay_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_PRE_long_decay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_PRE_short_level_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_PRE_short_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_PRE_short_decay_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_PRE_short_decay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+/* TODO - fix for vsc3312*/
+static ssize_t input_terminate_low_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_terminate_low_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_terminate_high_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t input_terminate_high_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_level_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t output_mode_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t output_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t forward_OOB_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t forward_OOB_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t status_0_on_LOS_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t status_0_on_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t status_1_on_LOS_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t status_1_on_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t status_show (struct device *dev, struct device_attribute *attr, char *buf);
+/* global */
+static ssize_t global_connection_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_connection_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_ISE_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_ISE_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_input_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_input_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_input_LOS_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_input_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_output_PRE_long_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_output_PRE_long_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_output_PRE_short_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_output_PRE_short_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_output_level_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_output_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_output_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_output_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_status_0_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_status_0_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t global_status_1_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t global_status_1_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t core_config_word_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t core_config_word_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t core_left_bias_en_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t core_left_bias_en_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t core_right_bias_en_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t core_right_bias_en_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t core_buffer_on_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t core_buffer_on_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t core_config_pin_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t core_config_pin_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t soft_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t address_range_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t address_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t status_combo_show (struct device *dev, struct device_attribute *attr, char *buf);
+
+/* Global registers - writes applied to all port registers. No sense to read (so write only), but functions preserved
+ * Placed in "globals" directory */
+static DEVICE_ATTR(connection,        SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_connection_show, global_connection_store);
+static DEVICE_ATTR(ISE,               SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_ISE_show, global_ISE_store);
+static DEVICE_ATTR(input_state,       SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_input_state_show, global_input_state_store);
+static DEVICE_ATTR(input_LOS,         SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_input_LOS_show, global_input_LOS_store);
+static DEVICE_ATTR(output_PRE_long,   SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_output_PRE_long_show,  global_output_PRE_long_store);
+static DEVICE_ATTR(output_PRE_short,  SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_output_PRE_short_show, global_output_PRE_short_store);
+static DEVICE_ATTR(output_level,      SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_output_level_show, global_output_level_store);
+static DEVICE_ATTR(output_state,      SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_output_state_show, global_output_state_store);
+static DEVICE_ATTR(status_0_on_LOS,   SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_status_0_show, global_status_0_store);
+static DEVICE_ATTR(status_1_on_LOS,   SYSFS_PERMISSIONS & SYSFS_WRITEONLY, global_status_1_show, global_status_1_store);
+
+/* control/status registers , placed in "control" directory */
+static DEVICE_ATTR(core_word,         SYSFS_PERMISSIONS,                   core_config_word_show, core_config_word_store);
+static DEVICE_ATTR(core_left_bias_en, SYSFS_PERMISSIONS,                   core_left_bias_en_show, core_left_bias_en_store);
+static DEVICE_ATTR(core_right_bias_en,SYSFS_PERMISSIONS,                   core_right_bias_en_show, core_right_bias_en_store);
+static DEVICE_ATTR(core_buffer_on,    SYSFS_PERMISSIONS,                   core_buffer_on_show, core_buffer_on_store);
+static DEVICE_ATTR(core_config_pin_invert,SYSFS_PERMISSIONS,               core_config_pin_invert_show, core_config_pin_invert_store);
+static DEVICE_ATTR(soft_reset,        SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,                        soft_reset_store);
+static DEVICE_ATTR(address_range,     SYSFS_PERMISSIONS,                   address_range_show,          address_range_store);
+static DEVICE_ATTR(status,            SYSFS_PERMISSIONS & SYSFS_READONLY,  status_combo_show, NULL);
+
+static struct attribute *globals_dev_attrs[] = {
+	&dev_attr_connection.attr,
+	&dev_attr_ISE.attr,
+	&dev_attr_input_state.attr,
+	&dev_attr_input_LOS.attr,
+	&dev_attr_output_PRE_long.attr,
+	&dev_attr_output_PRE_short.attr,
+	&dev_attr_output_level.attr,
+	&dev_attr_output_state.attr,
+	&dev_attr_status_0_on_LOS.attr,
+	&dev_attr_status_1_on_LOS.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_globals_group = {
+	.attrs = globals_dev_attrs,
+	.name  = "globals",
+};
+
+static struct attribute *control_dev_attrs[] = {
+	&dev_attr_core_word.attr,
+	&dev_attr_core_left_bias_en.attr,
+	&dev_attr_core_right_bias_en.attr,
+	&dev_attr_core_buffer_on.attr,
+	&dev_attr_core_config_pin_invert.attr,
+	&dev_attr_soft_reset.attr,
+	&dev_attr_address_range.attr,
+	&dev_attr_status.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_control_group = {
+	.attrs = control_dev_attrs,
+	.name  = "control",
+};
+
+
+/* seems we need to INITIALIZE all structures to zero - examples use static */
+static int make_group (struct device *dev, const char * name, int port_mask, mode_t mode,
+		ssize_t (*show)(struct device *dev, struct device_attribute *attr,
+				char *buf),
+		ssize_t (*store)(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+){
+	int retval=-1;
+	int port,index=0,num_regs;
+	struct attribute **pattrs; /* array of pointers to attibutes */
+	struct device_attribute *dev_attrs;
+	struct attribute_group *attr_group;
+	for (port=0,num_regs=1;port<MAX_PORTS;port++) if (port_mask & (1<<port)) num_regs++; /* 1 extra - used for all ports */
+
+	pattrs = devm_kzalloc(dev, (num_regs+1)*sizeof(pattrs[0]), GFP_KERNEL);
+	if (!pattrs) return -ENOMEM;
+	dev_attrs = devm_kzalloc(dev, num_regs*sizeof(dev_attrs[0]), GFP_KERNEL);
+	if (!dev_attrs) return -ENOMEM;
+	attr_group = devm_kzalloc(dev, sizeof(*attr_group), GFP_KERNEL);
+	if (!attr_group) return -ENOMEM;
+	memset(dev_attrs,  0, num_regs*sizeof(dev_attrs[0]));
+	memset(attr_group, 0, sizeof(*attr_group));
+	for (port=0,index=0;port<MAX_PORTS;port++) if (port_mask & (1<<port)){
+		dev_attrs[index].attr.name=port_names[port];
+		dev_attrs[index].attr.mode=mode;
+		dev_attrs[index].show= show;
+		dev_attrs[index].store=store;
+ 		pattrs[index]=&(dev_attrs[index].attr);
+ 		index++;
+	}
+	/*  add all ports */
+	dev_attrs[index].attr.name=ALL_PORTS;
+	dev_attrs[index].attr.mode=mode; /* & 0222; */ /* write only */
+	dev_attrs[index].show= show;
+	dev_attrs[index].store=store;
+	pattrs[index]=&(dev_attrs[index].attr);
+	index++;
+	pattrs[index]=NULL;
+
+	attr_group->name  = name;
+	attr_group->attrs =pattrs;
+	dev_dbg(dev,"name=%s, &dev->kobj=0x%08x\n",attr_group->name, (int) (&dev->kobj));
+	index=0;
+	while ((*attr_group).attrs[index]){
+		dev_dbg(dev,"attr=%s\n",attr_group->attrs[index]->name);
+		index++;
+	}
+    if (&dev->kobj) {
+    	retval = sysfs_create_group(&dev->kobj, attr_group);
+    }
+	return retval;
+}
+
+static int vsc330x_sysfs_register(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+    int ports=clientdata->out_ports;
+    int retval=0;
+    if (&dev->kobj) {
+    	if ((retval=make_group (dev, "connections",           ports, SYSFS_PERMISSIONS, connection_show, connection_store))) return retval;
+    	if ((retval=make_group (dev, "input_ISE_short",       ports, SYSFS_PERMISSIONS, input_ISE_short_show, input_ISE_short_store))) return retval;
+    	if ((retval=make_group (dev, "input_ISE_medium",      ports, SYSFS_PERMISSIONS, input_ISE_medium_show, input_ISE_medium_store))) return retval;
+    	if ((retval=make_group (dev, "input_ISE_long",        ports, SYSFS_PERMISSIONS, input_ISE_long_show, input_ISE_long_store))) return retval;
+    	if ((retval=make_group (dev, "input_state_off",       ports, SYSFS_PERMISSIONS, input_state_off_show, input_state_off_store))) return retval;
+    	if ((retval=make_group (dev, "input_state_invert",    ports, SYSFS_PERMISSIONS, input_state_invert_show, input_state_invert_store))) return retval;
+    	if ((retval=make_group (dev, "input_LOS_threshold",   ports, SYSFS_PERMISSIONS, input_LOS_threshold_show, input_LOS_threshold_store))) return retval;
+    	if ((retval=make_group (dev, "output_PRE_long_level", ports, SYSFS_PERMISSIONS, output_PRE_long_level_show, output_PRE_long_level_store))) return retval;
+    	if ((retval=make_group (dev, "output_PRE_long_decay", ports, SYSFS_PERMISSIONS, output_PRE_long_decay_show, output_PRE_long_decay_store))) return retval;
+    	if ((retval=make_group (dev, "output_PRE_short_level",ports, SYSFS_PERMISSIONS, output_PRE_short_level_show, output_PRE_short_level_store))) return retval;
+    	if ((retval=make_group (dev, "output_PRE_short_decay",ports, SYSFS_PERMISSIONS, output_PRE_short_decay_show, output_PRE_short_decay_store))) return retval;
+    	if ((retval=make_group (dev, "input_terminate_low",   ports, SYSFS_PERMISSIONS, input_terminate_low_show, input_terminate_low_store))) return retval;
+    	if ((retval=make_group (dev, "input_terminate_high",  ports, SYSFS_PERMISSIONS, input_terminate_high_show, input_terminate_high_store))) return retval;
+    	if ((retval=make_group (dev, "output_level",          ports, SYSFS_PERMISSIONS, output_level_show, output_level_store))) return retval;
+    	if ((retval=make_group (dev, "output_mode",           ports, SYSFS_PERMISSIONS, output_mode_show, output_mode_store))) return retval;
+    	if ((retval=make_group (dev, "forward_OOB",           ports, SYSFS_PERMISSIONS, forward_OOB_show, forward_OOB_store))) return retval;
+    	if ((retval=make_group (dev, "status_0_on_LOS",       ports, SYSFS_PERMISSIONS, status_0_on_LOS_show, status_0_on_LOS_store))) return retval;
+    	if ((retval=make_group (dev, "status_1_on_LOS",       ports, SYSFS_PERMISSIONS, status_1_on_LOS_show, status_1_on_LOS_store))) return retval;
+    	if ((retval=make_group (dev, "status",                ports, SYSFS_PERMISSIONS & SYSFS_READONLY, status_show, NULL))) return retval;
+
+    	if ((retval = sysfs_create_group(&dev->kobj, &dev_attr_globals_group))) return retval;
+    	if ((retval = sysfs_create_group(&dev->kobj, &dev_attr_control_group))) return retval;
+    }
+    return retval;
+}
+
+
+static ssize_t field_show(struct device *dev, struct device_attribute *attr, char *buf,
+		int page, int ls_bit_num, int width)
+{
+	int reg, port_mask, rc=0, len=0, count=PAGE_SIZE;
+	struct i2c_client *client = to_i2c_client(dev);
+   /* do for all ports - not used. TODO: we can try to output all of them in a row, but not sure if count will permit*/
+	if (strcmp(attr->attr.name,ALL_PORTS) == 0) {
+		port_mask=((struct vsc330x_data_t *) i2c_get_clientdata(to_i2c_client(dev)))->out_ports;
+		for (reg=0;reg<MAX_PORTS;reg++) if ((port_mask & (1<<reg)) && (count>5)) {
+			dev_dbg(dev, "name='%s' reg=0x%x, page=0x%x, ls_bit_num=0x%x, width=0x%x\n",
+					attr->attr.name, reg, page, ls_bit_num,  width);
+			rc = read_page_field(client, page, reg, ls_bit_num, width);
+//		    rc=field_show_reg(dev, buf, page, reg, ls_bit_num, width);
+		    if (rc<0) return rc;
+		    rc=sprintf(buf, "%d ", rc);
+		    buf+=rc;
+		    len+=rc;
+		    count-=rc;
+
+		}
+		if (len>0) {
+			len--;
+			count++;
+			buf--;
+		}
+	    rc=sprintf(buf, "\n");
+	    buf+=rc;
+	    len+=rc;
+	    count-=rc;
+	    return len;
+	}
+	/* process single port */
+	sscanf(attr->attr.name+strlen(PORT_PEFIX), "%du", &reg);
+	dev_dbg(dev, "name='%s' name+%d='%s' reg=0x%x, page=0x%x, ls_bit_num=0x%x, width=0x%x\n",
+			attr->attr.name, strlen(PORT_PEFIX), ( attr->attr.name+strlen(PORT_PEFIX)),  reg, page, ls_bit_num,  width);
+    return field_show_reg(dev, buf, page, reg, ls_bit_num, width);
+}
+
+static ssize_t field_show_reg(struct device *dev, char *buf, int page, int reg, int ls_bit_num, int width)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int data=read_page_field(client, page, reg, ls_bit_num, width);
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t field_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,
+		int page, int ls_bit_num, int width)
+{
+	int reg, port_mask, rc;
+   /* do for all ports */
+	if (strcmp(attr->attr.name,ALL_PORTS) == 0) {
+		port_mask=((struct vsc330x_data_t *) i2c_get_clientdata(to_i2c_client(dev)))->out_ports;
+		for (reg=0;reg<MAX_PORTS;reg++) if (port_mask & (1<<reg)) {
+			dev_dbg(dev, "name='%s' reg=0x%x, page=0x%x, ls_bit_num=0x%x, width=0x%x\n",
+					attr->attr.name, reg, page, ls_bit_num,  width);
+			rc= field_store_reg(dev, buf, count, page, reg, ls_bit_num, width);
+		    if (rc<0) return rc;
+		}
+	    return count;
+	}
+	/* process single port */
+	sscanf(attr->attr.name+strlen(PORT_PEFIX), "%du", &reg);
+	dev_dbg(dev, "name='%s' name+%d='%s' reg=0x%x, page=0x%x, ls_bit_num=0x%x, width=0x%x\n",
+			attr->attr.name, strlen(PORT_PEFIX), ( attr->attr.name+strlen(PORT_PEFIX)),  reg, page, ls_bit_num,  width);
+
+	return field_store_reg(dev, buf, count, page, reg, ls_bit_num, width);
+}
+static ssize_t field_store_reg(struct device *dev, const char *buf, size_t count,
+		int page, int reg, int ls_bit_num, int width)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int val,rc;
+    sscanf(buf, "%du", &val);
+    rc=write_page_field(client, page, reg, val, ls_bit_num, width);
+    return count;
+}
+
+
+static ssize_t connection_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_CONNECTION, 0, 5);}
+static ssize_t connection_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_CONNECTION, 0, 5);}
+
+static ssize_t input_ISE_short_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_ISE, 4, 2);}
+static ssize_t input_ISE_short_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_ISE, 4, 2);}
+
+static ssize_t input_ISE_medium_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_ISE, 2, 2);}
+static ssize_t input_ISE_medium_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_ISE, 2, 2);}
+
+static ssize_t input_ISE_long_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_ISE, 0, 2);}
+static ssize_t input_ISE_long_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_ISE, 0, 2);}
+
+static ssize_t input_state_off_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_STATE, 1, 1);}
+static ssize_t input_state_off_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_STATE, 1, 1);}
+
+static ssize_t input_state_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_STATE, 0, 1);}
+static ssize_t input_state_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_STATE, 0, 1);}
+
+static ssize_t input_LOS_threshold_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_LOS, 0, 3);}
+static ssize_t input_LOS_threshold_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_LOS, 0, 3);}
+
+static ssize_t output_PRE_long_level_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_PRE_LONG, 3, 4);}
+static ssize_t output_PRE_long_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_PRE_LONG, 3, 4);}
+
+static ssize_t output_PRE_long_decay_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_PRE_LONG, 0, 3);}
+static ssize_t output_PRE_long_decay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_PRE_LONG, 0, 3);}
+
+static ssize_t output_PRE_short_level_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_PRE_SHORT, 3, 4);}
+static ssize_t output_PRE_short_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_PRE_SHORT, 3, 4);}
+
+static ssize_t output_PRE_short_decay_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_PRE_SHORT, 0, 3);}
+static ssize_t output_PRE_short_decay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_PRE_SHORT, 0, 3);}
+/* TODO - fix for vsc3312*/
+static ssize_t input_terminate_low_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_INPUT_STATE, 2, 1);}
+static ssize_t input_terminate_low_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_INPUT_STATE, 2, 1);}
+static ssize_t input_terminate_high_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_LEVEL, 4, 1);}
+static ssize_t input_terminate_high_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_LEVEL, 4, 1);}
+
+static ssize_t output_level_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_LEVEL, 0, 4);}
+static ssize_t output_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_LEVEL, 0, 4);}
+
+static ssize_t output_mode_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_STATE, 1, 4);}
+static ssize_t output_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_STATE, 1, 4);}
+
+static ssize_t forward_OOB_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_OUTPUT_STATE, 0, 1);}
+static ssize_t forward_OOB_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_OUTPUT_STATE, 0, 1);}
+
+static ssize_t status_0_on_LOS_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_STATUS0_CONFIGURE, 0, 1);}
+static ssize_t status_0_on_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_STATUS0_CONFIGURE, 0, 1);}
+
+static ssize_t status_1_on_LOS_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show(dev, attr, buf,         I2C_PAGE_STATUS1_CONFIGURE, 0, 1);}
+static ssize_t status_1_on_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store(dev, attr, buf, count, I2C_PAGE_STATUS1_CONFIGURE, 0, 1);}
+/* per-port LOS status */
+static ssize_t status_show (struct device *dev, struct device_attribute *attr, char *buf)
+    {return field_show(dev, attr, buf,         I2C_PAGE_STATUS_READ, 0, 1);}
+/* combined LOS status */
+static ssize_t status_combo_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg(dev, buf, I2C_PAGE_STATUS_READ, 0x10, 0, 2);}
+
+
+/* Global registers use all 8 bits (and control multiple features at once, because it is not possible to read-modify-write them */
+static ssize_t global_connection_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_CONNECTION, 0, 8);}
+static ssize_t global_connection_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_CONNECTION, 0, 8);}
+
+
+static ssize_t global_ISE_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_ISE, 0, 8);}
+static ssize_t global_ISE_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_ISE, 0, 8);}
+
+static ssize_t global_input_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_STATE, 0, 8);}
+static ssize_t global_input_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_STATE, 0, 8);}
+
+static ssize_t global_input_LOS_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_LOS, 0, 8);}
+static ssize_t global_input_LOS_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_INPUT_LOS, 0, 8);}
+
+static ssize_t global_output_PRE_long_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_PRE_LONG, 0, 8);}
+static ssize_t global_output_PRE_long_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_PRE_LONG, 0, 8);}
+
+static ssize_t global_output_PRE_short_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_PRE_SHORT, 0, 8);}
+static ssize_t global_output_PRE_short_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_PRE_SHORT, 0, 8);}
+
+static ssize_t global_output_level_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_LEVEL, 0, 8);}
+static ssize_t global_output_level_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_LEVEL, 0, 8);}
+
+static ssize_t global_output_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_STATE, 0, 8);}
+static ssize_t global_output_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_OUTPUT_STATE, 0, 8);}
+
+static ssize_t global_status_0_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_STATUS0, 0, 8);}
+static ssize_t global_status_0_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_STATUS0, 0, 8);}
+
+static ssize_t global_status_1_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_GLOBAL_STATUS1, 0, 8);}
+static ssize_t global_status_1_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_GLOBAL_STATUS1, 0, 8);}
+
+static ssize_t core_config_word_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 0, 8);}
+static ssize_t core_config_word_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 0, 8);} /* 0x18/ 0x19 for 3312 */
+
+static ssize_t core_left_bias_en_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 4, 1);}
+static ssize_t core_left_bias_en_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 4, 1);}
+
+static ssize_t core_right_bias_en_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 3, 1);}
+static ssize_t core_right_bias_en_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 3, 1);}
+
+static ssize_t core_buffer_on_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 1, 1);}
+static ssize_t core_buffer_on_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 1, 1);}
+
+static ssize_t core_config_pin_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 0, 1);}
+static ssize_t core_config_pin_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_CORE_CONFIGURATION, 0, 1);}
+
+static ssize_t soft_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int rc;
+	if (((rc=field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_SOFTWARE_RESET, 4, 1)))<0) return rc;
+	if (((rc=init_device(client)))<0) return rc;
+	return count;
+}
+
+static ssize_t address_range_show (struct device *dev, struct device_attribute *attr, char *buf)
+	{return field_show_reg (dev, buf,        I2C_PAGE_GLOBAL, I2C_SOFTWARE_RESET, 0, 4);}
+static ssize_t address_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return field_store_reg(dev, buf, count, I2C_PAGE_GLOBAL, I2C_SOFTWARE_RESET, 0, 4);}
+
+/* Setup i2c, write address_mode. Needed after soft reset and power up */
+
+static int _init_device(struct i2c_client *client, int address_mode_data)
+{
+	int rc;
+    if (((rc=write_reg(client, I2C_INTERFACE_MODE, I2C_INTERFACE_MODE_DATA)))<0) return rc;
+    if (address_mode_data >=0){ /* only write if needed, 3304 needs, 3312 - does not, 3308 - ? */
+        if (((rc=write_reg(client, I2C_SOFTWARE_RESET_DATA, address_mode_data)))<0) return rc;
+    }
+    if (((rc=write_reg(client, I2C_CURRENT_PAGE, 0)))<0) return rc;
+	return 0;
+}
+
+
+static int init_device(struct i2c_client *client)
+{
+	int rc;
+	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+	dev_info(&client->dev,"Re-initializing %s\n",client->name);
+	if (((rc=_init_device(client, clientdata->address_mode_data)))<0) return rc;
+	clientdata->last_page=0;
+	return 0;
+}
+
+static int bitmask(int ls_bit_num, int width)
+{
+	return ((1 << width) -1) << ls_bit_num;
+}
+//address_mode_data
+static int read_reg(struct i2c_client *client, u8 reg)
+{
+	int val;
+	val= i2c_smbus_read_byte_data(client, reg);
+	dev_dbg(&client->dev,"reading i2c device : slave=0x%x, reg=0x%x -> 0x%x\n",(int) (client->addr),reg,val);
+	return val;
+}
+
+static int write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	dev_dbg(&client->dev,"device write: slave=0x%x, reg=0x%x, val=0x%x\n", (int) (client->addr),reg,val);
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int read_field(struct i2c_client *client, u8 reg, int ls_bit_num, int width)
+{
+	int rc;
+	if (((rc=read_reg(client, reg)))<0) return rc;
+	rc= (rc >> ls_bit_num) & bitmask(0, width);
+	dev_dbg(&client->dev,"reg=0x%x, ls_bit_num=%d, width=%d -> 0x%x\n", (int) reg, ls_bit_num,width,rc);
+    return rc;
+}
+static int read_page_field(struct i2c_client *client, int page, u8 reg, int ls_bit_num, int width)
+{
+	int rc;
+	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+	dev_dbg(&client->dev,"page=0x%x (last was 0x%x) reg=0x%x, ls_bit_num=%d, width=%d:\n",
+			page, (clientdata->last_page!=page), (int) reg, ls_bit_num, width);
+	if ((page>=0) && (clientdata->last_page!=page)) {
+		if (((rc=write_reg(client, I2C_CURRENT_PAGE, page)))<0) return rc;
+		clientdata->last_page=page;
+	}
+	rc= read_field(client, reg, ls_bit_num, width);
+	dev_dbg(&client->dev,"page=0x%x (last was 0x%x) reg=0x%x, ls_bit_num=%d, width=%d -> 0x%x\n",
+			page, (clientdata->last_page!=page), (int) reg, ls_bit_num, width,rc);
+	return rc;
+}
+static int write_field(struct i2c_client *client, u8 reg, u8 val, int ls_bit_num, int width)
+{
+	int rc;
+	dev_dbg(&client->dev,"reg=0x%x, val=0x%x, ls_bit_num=%d, width=%d \n", (int) reg, (int) val,ls_bit_num,width);
+	if (((rc=read_reg(client, reg)))<0) return rc;
+	val<<=ls_bit_num;
+	return  write_reg(client, reg, ((rc ^ val) &  bitmask(ls_bit_num, width))^ rc);
+}
+
+static int write_page_field(struct i2c_client *client, int page, u8 reg, u8 val, int ls_bit_num, int width)
+{
+	int rc;
+	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+	dev_dbg(&client->dev,"page=0x%x (last was 0x%x), reg=0x%x, val=0x%x, ls_bit_num=%d, width=%d \n",
+			page,clientdata->last_page, (int) reg, (int) val,ls_bit_num,width);
+	if ((page>=0) && (clientdata->last_page!=page)) {
+		if (((rc=write_reg(client, I2C_CURRENT_PAGE, page)))<0) return rc;
+		clientdata->last_page=page;
+	}
+	return write_field(client, reg, val, ls_bit_num, width);
+}
+
+static int write_with_mask(struct i2c_client *client, u8 reg, u8 val, u8 mask)
+{
+	int rc;
+	dev_dbg(&client->dev,"reg=0x%x, val=0x%x, mask=0x%x\n", (int) reg, (int) val, (int) mask);
+	if (mask !=0xff){
+	    if (((rc=read_reg(client, reg)))<0) return rc;
+	    val=((val ^ rc) & mask)^ rc;
+	}
+	return  write_reg(client, reg, val);
+}
+
+static int write_page_with_mask(struct i2c_client *client, int page, u8 reg, u8 val , u8 mask)
+{
+	int rc;
+	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+	dev_dbg(&client->dev,"page=0x%x (last was 0x%x), reg=0x%x, val=0x%x, mask=0x%x\n",
+			page,clientdata->last_page, (int) reg, (int) val,(int) mask);
+	if ((page>=0) && (clientdata->last_page!=page)) {
+		if (((rc=write_reg(client, I2C_CURRENT_PAGE, page)))<0) return rc;
+		clientdata->last_page=page;
+	}
+	return write_with_mask(client, reg, val, mask);
+}
+
+
+
+static void vsc330x_init_of(struct i2c_client *client)
+{
+//	struct device *dev=&client->dev;
+	const __be32 * config_data;
+	struct device_node *node = client->dev.of_node;
+    int len,i,rc;
+    struct vsc330x_setup_data  {
+    	u8		page;
+    	u8		reg;
+    	u8		data;
+    	u8		mask;
+    };
+    struct vsc330x_setup_data setup_data;
+    __be32 * setup_data_be32= (__be32 *) &setup_data;
+
+
+    const char * config_name;
+	if (node) {
+
+		config_name = of_get_property(client->dev.of_node, "vsc330x,configuration_name", &len);
+		if (config_name){
+			dev_info(&client->dev,"Initializing %s registers for \"%s\"\n",client->name,config_name);
+		}
+		config_data = of_get_property(client->dev.of_node, "vsc330x,configuration_data", &len);
+		if (config_data){
+			len /= sizeof(*config_data);
+			dev_dbg(&client->dev,"Read %d values\n",len);
+			for (i=0;i<len;i++){
+			    dev_dbg(&client->dev,"0x%08x (0x%08x)\n", config_data[i],be32_to_cpup(config_data+i));
+				*setup_data_be32=config_data[i];
+			    dev_dbg(&client->dev,"page=0x%02x, reg=0x%02x, data=0x%02x, mask=0x%02x \n",
+			    		(int)setup_data.page, (int)setup_data.reg,(int)setup_data.data,(int)setup_data.mask);
+			    if (((rc=write_page_with_mask(client, (setup_data.page==0xff)?-1:setup_data.page, setup_data.reg,
+			    		setup_data.data, setup_data.mask)))<0) return rc;
+			}
+		} else {
+			dev_info(&client->dev,"'vsc330x,configuration_data' not found\n");
+		}
+	} else {
+		dev_info(&client->dev,"Device tree data not found for %s\n",client->name);
+	}
+}
+/*
+ 	dev_info(&client->dev,
+
+ */
+
+
+
+
+static int vsc330x_i2c_probe(struct i2c_client *client,
+				      const struct i2c_device_id *id)
+{
+	int rc=0;
+	struct vsc330x_data_t *clientdata = NULL;
+	/* initialize i2c mode and (if needed) address range bit field */
+
+	if (((rc=_init_device(client, vsc330x_data[id->driver_data].address_mode_data)))<0) goto wr_err;
+	dev_info(&client->dev,
+		 "Chip %s found, driver version %s\n", id->name, DRV_VERSION);
+	clientdata = devm_kzalloc(&client->dev, sizeof(*clientdata), GFP_KERNEL);
+	if (!clientdata) {
+		rc = -ENOMEM;
+		goto exit;
+	}
+	clientdata->last_page = 0;
+	clientdata->address_mode_data = vsc330x_data[id->driver_data].address_mode_data;
+	clientdata->in_ports = vsc330x_data[id->driver_data].in_ports;
+	clientdata->out_ports = vsc330x_data[id->driver_data].out_ports;
+	i2c_set_clientdata(client, clientdata);
+	rc = vsc330x_sysfs_register(&client->dev);
+	if (rc)
+		goto exit;
+	vsc330x_init_of(client);
+	return 0;	/* found OK*/
+wr_err:
+	rc = -EIO;
+	dev_err(&client->dev, "%s:%d error writing\n",__func__,__LINE__);
+	goto exit;
+#if 0
+rd_err:
+	rc = -EIO;
+	dev_err(&client->dev, "%s:%d error reading\n",__func__,__LINE__);
+	goto exit;
+#endif
+exit:
+	return rc;
+
+}
+
+static int vsc330x_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static struct i2c_driver vsc330x_i2c_driver = {
+	.driver = {
+		.name	= "vsc330x",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= vsc330x_i2c_probe,
+	.remove		= vsc330x_i2c_remove,
+	.id_table	= vsc330x_id,
+};
+
+module_i2c_driver(vsc330x_i2c_driver);
+
+MODULE_AUTHOR("Andrey Filippov  <andrey@elphel.com>");
+MODULE_DESCRIPTION("VSC330x I2C bus driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("i2c:vsc330x");
+
+
Index: git/drivers/misc/si5338.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/drivers/misc/si5338.c	2013-12-05 01:46:25.412220716 -0700
@@ -0,0 +1,3360 @@
+/*!***************************************************************************
+ *! FILE NAME  : si5338.c
+ *! DESCRIPTION: control of the Silicon Laboratories SI5338 clock generator
+ *! Copyright (C) 2013 Elphel, Inc.
+ *! -----------------------------------------------------------------------------**
+ *!
+ *!  This program is free software: you can redistribute it and/or modify
+ *!  it under the terms of the GNU General Public License as published by
+ *!  the Free Software Foundation, either version 3 of the License, or
+ *!  (at your option) any later version.
+ *!
+ *!  This program is distributed in the hope that it will be useful,
+ *!  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *!  GNU General Public License for more details.
+ *!
+ *!  You should have received a copy of the GNU General Public License
+ *!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#include <linux/math64.h>
+
+
+#define DRV_VERSION "1.0"
+#define SYSFS_PERMISSIONS         0644 /* default permissions for sysfs files */
+#define SYSFS_READONLY            0444
+#define SYSFS_WRITEONLY           0222
+
+
+
+#define REG5338_PAGE               255
+#define REG5338_PAGE_MASK            1
+#define REG5338_DEV_CONFIG2          2
+#define REG5338_DEV_CONFIG2_MASK  0x3f
+#define REG5338_DEV_CONFIG2_VAL    38 /* last 2 digits of part number */
+#define LAST_REG                   347
+
+#define FVCOMIN                    2200000000LL
+#define FVCOMAX                    2840000000LL
+#define INFREQMIN                     5000000LL
+#define INFREQMAX                   710000000LL
+#define MSINT_MIN                  8 /* not considering 4,6 */
+#define MSINT_MAX                  567
+
+#define AWE_IN_MUX                 0x1d18
+#define AWE_IN_MUX1                0x1c1c
+#define AWE_FB_MUX                 0x1e18
+#define AWE_FB_MUX1                0x1c20
+
+#define AWE_XTAL_FREQ              0x1c03
+#define AWE_PFD_REF                0x1de0
+#define AWE_PFD_FB                 0x1ee0
+#define AWE_P1DIV                  0x1d07
+#define AWE_P2DIV                  0x1e07
+#define AWE_DRV0_PDN               0x1f01
+#define AWE_MS0_PDN                0x1f02
+#define AWE_R0DIV                  0x1f1c
+#define AWE_R0DIV_IN               0x1fe0
+#define AWE_DRV1_PDN               0x2001
+#define AWE_MS1_PDN                0x2002
+#define AWE_R1DIV                  0x201c
+#define AWE_R1DIV_IN               0x20e0
+#define AWE_DRV2_PDN               0x2101
+#define AWE_MS2_PDN                0x2102
+#define AWE_R2DIV                  0x211c
+#define AWE_R2DIV_IN               0x21e0
+#define AWE_DRV3_PDN               0x2201
+#define AWE_MS3_PDN                0x2202
+#define AWE_R3DIV                  0x221c
+#define AWE_R3DIV_IN               0x22e0
+
+#define AWE_DRV0_VDDO              0x2303
+#define AWE_DRV1_VDDO              0x230c
+#define AWE_DRV2_VDDO              0x2330
+#define AWE_DRV3_VDDO              0x23c0
+#define AWE_DRV0_FMT               0x2407
+#define AWE_DRV0_INV               0x2418
+#define AWE_DRV1_FMT               0x2507
+#define AWE_DRV1_INV               0x2518
+#define AWE_DRV2_FMT               0x2607
+#define AWE_DRV2_INV               0x2618
+#define AWE_DRV3_FMT               0x2707
+#define AWE_DRV3_INV               0x2718
+
+#define AWE_DRV0_TRIM              0x281f
+#define AWE_DRV1_TRIM_A            0x28e0
+#define AWE_DRV1_TRIM_B            0x2903
+#define AWE_DRV2_TRIM              0x297c
+#define AWE_DRV3_TRIM              0x2a1f
+
+#define AWE_FCAL_OVRD_A            0x2bff
+#define AWE_FCAL_OVRD_B            0x2cff
+#define AWE_FCAL_OVRD_C            0x2d03
+
+#define AWE_FCAL_OVRD_07_00        0x2dff
+#define AWE_FCAL_OVRD_15_08        0x2eff
+#define AWE_FCAL_OVRD_17_15        0x2f03
+#define AWE_PFD_EXTFB              0x3080
+#define AWE_PLL_KPHI               0x307f
+#define AWE_FCAL_OVRD_EN           0x3180
+#define AWE_VCO_GAIN               0x3170
+#define AWE_RSEL                   0x310c
+#define AWE_BWSEL                  0x3103
+#define AWE_VCO_GAIN_RSEL_BWSEL    0x317f
+
+#define AWE_PLL_EN                 0x32c0
+#define AWE_MSCAL                  0x323f
+#define AWE_MS3_HS                 0x3380
+#define AWE_MS2_HS                 0x3340
+#define AWE_MS1_HS                 0x3320
+#define AWE_MS0_HS                 0x3310
+#define AWE_MS_PEC                 0x3307
+
+#define AWE_MS0_FIDCT              0x3460
+#define AWE_MS0_FIDDIS             0x3410
+#define AWE_MS0_SSMODE             0x340C
+#define AWE_MS0_PHIDCT             0x3403
+#define AWE_MS0_P1_07_00           0x35ff
+#define AWE_MS0_P1_15_08           0x36ff
+#define AWE_MS0_P1_17_16           0x3703
+#define AWE_MS0_P2_05_00           0x37fc
+#define AWE_MS0_P2_13_06           0x38ff
+#define AWE_MS0_P2_21_14           0x39ff
+#define AWE_MS0_P2_29_22           0x3aff
+#define AWE_MS0_P3_07_00           0x3bff
+#define AWE_MS0_P3_15_08           0x3cff
+#define AWE_MS0_P3_23_16           0x3dff
+#define AWE_MS0_P3_29_24           0x3e3f
+
+
+#define AWE_MS1_FIDCT              0x3f60
+#define AWE_MS1_FIDDIS             0x3f10
+#define AWE_MS1_SSMODE             0x3f0C
+#define AWE_MS1_PHIDCT             0x3f03
+#define AWE_MS1_P1_07_00           0x40ff
+#define AWE_MS1_P1_15_08           0x41ff
+#define AWE_MS1_P1_17_16           0x4203
+#define AWE_MS1_P2_05_00           0x42fc
+#define AWE_MS1_P2_13_06           0x43ff
+#define AWE_MS1_P2_21_14           0x44ff
+#define AWE_MS1_P2_29_22           0x45ff
+#define AWE_MS1_P3_07_00           0x46ff
+#define AWE_MS1_P3_15_08           0x47ff
+#define AWE_MS1_P3_23_16           0x48ff
+#define AWE_MS1_P3_29_24           0x493f
+
+#define AWE_MS2_FRCTL              0x4a60 /* different name? */
+#define AWE_MS2_FIDDIS             0x4a10
+#define AWE_MS2_SSMODE             0x4a0C
+#define AWE_MS2_PHIDCT             0x4a03
+#define AWE_MS2_P1_07_00           0x4bff
+#define AWE_MS2_P1_15_08           0x4cff
+#define AWE_MS2_P1_17_16           0x4d03
+#define AWE_MS2_P2_05_00           0x4dfc
+#define AWE_MS2_P2_13_06           0x4eff
+#define AWE_MS2_P2_21_14           0x4fff
+#define AWE_MS2_P2_29_22           0x50ff
+#define AWE_MS2_P3_07_00           0x51ff
+#define AWE_MS2_P3_15_08           0x52ff
+#define AWE_MS2_P3_23_16           0x53ff
+#define AWE_MS2_P3_29_24           0x543f
+
+#define AWE_MS3_FIDCT              0x5560
+#define AWE_MS3_FIDDIS             0x5510
+#define AWE_MS3_SSMODE             0x550C
+#define AWE_MS3_PHIDCT             0x5503
+#define AWE_MS3_P1_07_00           0x56ff
+#define AWE_MS3_P1_15_08           0x57ff
+#define AWE_MS3_P1_17_16           0x5803
+#define AWE_MS3_P2_05_00           0x58fc
+#define AWE_MS3_P2_13_06           0x59ff
+#define AWE_MS3_P2_21_14           0x5aff
+#define AWE_MS3_P2_29_22           0x5bff
+#define AWE_MS3_P3_07_00           0x5cff
+#define AWE_MS3_P3_15_08           0x5dff
+#define AWE_MS3_P3_23_16           0x5eff
+#define AWE_MS3_P3_29_24           0x5f3f
+
+#define AWE_MSN_P1_07_00           0x61ff
+#define AWE_MSN_P1_15_08           0x62ff
+#define AWE_MSN_P1_17_16           0x6303
+#define AWE_MSN_P2_05_00           0x63fc
+#define AWE_MSN_P2_13_06           0x64ff
+#define AWE_MSN_P2_21_14           0x65ff
+#define AWE_MSN_P2_29_22           0x66ff
+#define AWE_MSN_P3_07_00           0x67ff
+#define AWE_MSN_P3_15_08           0x68ff
+#define AWE_MSN_P3_23_16           0x69ff
+#define AWE_MSN_P3_29_24           0x6a3f
+
+#define AWE_OUT0_DIS_STATE         0x6ec0
+#define AWE_OUT1_DIS_STATE         0x72c0
+#define AWE_OUT2_DIS_STATE         0x76c0
+#define AWE_OUT3_DIS_STATE         0x7ac0
+
+
+#define AWE_OUT0_DIS               0xe601
+#define AWE_OUT1_DIS               0xe602
+#define AWE_OUT2_DIS               0xe604
+#define AWE_OUT3_DIS               0xe608
+#define AWE_OUT_ALL_DIS            0xe610
+
+
+
+#define AWE_MISC_47                0x2ffc /* write 0x5 */
+#define AWE_MISC_106               0x6a80 /* write 0x1 */
+#define AWE_MISC_116               0x7480 /* write 0x1 */
+#define AWE_MISC_42                0x2a20 /* write 0x1 */
+#define AWE_MISC_06A               0x06e0 /* write 0x0 */
+#define AWE_MISC_06B               0x0602 /* write 0x0 */
+#define AWE_MISC_28                0x1cc0 /* write 0x0 */
+
+#define CACHE_INIT                      1
+#define CACHE_VOLAT                     2
+
+struct si5338_cache_t {
+	u8 flags;
+	u8 data;
+};
+struct si5338_data_t {
+	u64 input_frequency12;
+	u64 input_frequency3;
+	u64 input_frequency4;
+	u64 input_frequency56;
+//	u64 pll_frequency;
+	int reg_addr;   /* used for raw register r/w */
+	int last_page;  /* value of last page accessed (bit 0 of register 255) */
+	struct mutex lock;
+	struct si5338_cache_t cache[LAST_REG+1];
+};
+
+static const struct i2c_device_id si5338_id[] = {
+	{ "si5338", 0 },
+	{ }
+};
+
+static void si5338_init_of(struct i2c_client *client);
+
+
+static ssize_t raw_address_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_address_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t raw_data_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_data_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t raw_hex_address_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_hex_address_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t raw_hex_data_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_hex_data_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t raw_hex_all_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_hex_adwe_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t raw_hex_adwe_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+//static ssize_t input_xtal_freq_show (struct device *dev, struct device_attribute *attr, char *buf);
+//static ssize_t input_xtal_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t input_xtal_freq_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_frequency12_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_frequency3_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_frequency4_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_frequency56_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_frequency12_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_frequency3_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_frequency4_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_frequency56_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _in_p12_div_show (struct device *dev, struct device_attribute *attr, char *buf,  int chn);
+static ssize_t _in_p12_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t in_p1_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_p1_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_p2_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_p2_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_mux_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_mux_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_mux_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t fb_mux_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t fb_mux_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t fb_mux_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_pfd_ref_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_pfd_ref_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_pfd_ref_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_pfd_fb_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t in_pfd_fb_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t in_pfd_fb_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t pll_ref_frequency_show (struct device *dev, struct device_attribute *attr, char *buf);
+
+static ssize_t _msx_p123_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _msx_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t _msx_abc_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _msx_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t ms0_p123_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms0_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms0_abc_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms0_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms1_p123_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms1_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms1_abc_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms1_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms2_p123_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms2_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms2_abc_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms2_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms3_p123_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms3_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms3_abc_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms3_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t msn_p123_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t msn_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t msn_abc_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t msn_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _ms_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _ms_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t ms0_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms1_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms2_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms3_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t ms0_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms1_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms2_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t ms3_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _pll_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int int_div, int by_out);
+static ssize_t pll_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_by_out_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_by_out_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _pll_ms_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _pll_ms_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int int_div, int chn);
+static ssize_t pll_ms0_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t pll_ms1_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t pll_ms2_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t pll_ms3_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t pll_ms0_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms1_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms2_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms3_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms0_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms1_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms2_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t pll_ms3_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t _out_source_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _out_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t _out_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _out_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t out0_source_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out1_source_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out2_source_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out3_source_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out0_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out1_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out2_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out3_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out0_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out1_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out2_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out3_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out0_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out1_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out2_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out3_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _out_div_show (struct device *dev, struct device_attribute *attr, char *buf,  int chn);
+static ssize_t _out_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t out0_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out1_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out2_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out3_div_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out0_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out1_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out2_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out3_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _out_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _out_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t out0_freq_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out1_freq_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out2_freq_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out3_freq_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t out0_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out1_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out2_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t out3_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+
+static ssize_t _drv_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_disable_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_disable_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_disable_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_disable_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_disable_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_invert_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_invert_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t drv0_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _drv_type_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_type_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_type_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_type_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_type_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t drv0_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _drv_vdd_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t _drv_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_vdd_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_vdd_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_vdd_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_vdd_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv0_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t drv0_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _drv_trim_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t drv0_trim_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_trim_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_trim_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_trim_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t _update_drv_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn);
+static ssize_t drv0_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv1_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv2_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t drv3_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t _drv_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn);
+static ssize_t drv0_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv1_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv2_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t drv3_txt_show (struct device *dev, struct device_attribute *attr, char *buf);
+
+/* -------------------------------------- */
+static int _verify_output_channel(struct i2c_client *client,int chn);
+static int get_drv_powerdown(struct i2c_client *client, int chn);
+static int set_drv_powerdown(struct i2c_client *client, int typ, int chn);
+static int get_drv_disable(struct i2c_client *client, int chn);
+static int set_drv_disable(struct i2c_client *client, int typ, int chn);
+static int get_drv_disabled_state(struct i2c_client *client, int chn);
+static int set_drv_disabled_state(struct i2c_client *client, int typ, int chn);
+static int get_drv_invert(struct i2c_client *client, int chn);
+static int set_drv_invert(struct i2c_client *client, int typ, int chn);
+static int get_drv_type(struct i2c_client *client, int chn);
+static int set_drv_type(struct i2c_client *client, int typ, int chn);
+static int get_drv_vdd(struct i2c_client *client, int chn);
+static int set_drv_vdd(struct i2c_client *client, int vdd, int chn);
+static int get_drv_trim(struct i2c_client *client, int chn);
+static int update_drv_trim(struct i2c_client *client, int novtt, int chn); /* no Vtt - CMOS, no termination, where it matters */
+static char * get_drv_txt(struct i2c_client *client, int chn);
+static int set_drv_trim_any(struct i2c_client *client, int trim, int chn);
+static int set_out_div(struct i2c_client *client, int div, int chn); /*chn =0..3 */
+static int get_out_div(struct i2c_client *client, int chn); /*chn =0..3 */
+static int set_out_div_by_frequency(struct i2c_client *client, u64* out_freq, int chn); /*chn =0..3 */
+static int get_out_frequency(struct i2c_client *client, u64* out_freq, int chn); /*chn =0..3 */
+static int get_out_source(struct i2c_client *client, int chn);
+static int set_out_source(struct i2c_client *client, int chn, int src);
+static s64 get_output_src_frequency(struct i2c_client *client, u64 *out_freq, int chn);
+
+
+static int set_pll_paremeters(struct i2c_client *client);
+static int set_misc_registers(struct i2c_client *client);
+static int get_ms_powerdown(struct i2c_client *client, int chn);
+static int set_ms_powerdown(struct i2c_client *client, int typ, int chn);
+static int ms_to_p123(u64* ms,u32 * p123);
+static int p123_to_ms(u64* ms,u32 * p123);
+static int get_ms_p123(struct i2c_client *client,u32 * p123, int chn); /* chn 0,1,2,3,4 (4 - msn) */
+static int set_ms_p123(struct i2c_client *client,u32 * p123, int chn); /* chn 0,1,2,3,4 (4 - msn) */
+static int set_pll_freq(struct i2c_client *client, u64 *vco_freq, int int_div);
+static int get_pll_freq(struct i2c_client *client,u64 * pll_freq);
+static int set_pll_freq_by_out(struct i2c_client *client, u64 *out_freq, int int_msn_div);
+
+static int get_pll_ms_freq(struct i2c_client *client, u64 *out_freq, int chn);
+static int set_pll_ms_by_out(struct i2c_client *client, u64 *out_freq, int chn, int int_div);
+static s64 get_pll_in_frequency(struct i2c_client *client);
+static s64 get_pll_fb_frequency(struct i2c_client *client);
+static s64 get_p1div_in_frequency(struct i2c_client *client);
+static s64 get_p2div_in_frequency(struct i2c_client *client);
+
+
+static int set_in_mux(struct i2c_client *client, int data);
+static int get_in_mux(struct i2c_client *client);
+static int set_fb_mux(struct i2c_client *client, int data);
+static int get_fb_mux(struct i2c_client *client);
+static int set_in_pdiv(struct i2c_client *client, int div, int chn); /*chn =0,1 */
+static int get_in_pdiv(struct i2c_client *client, int chn); /*chn =0,1 */
+static int set_in_pfd_ref_fb(struct i2c_client *client, u8 val, int chn); /*chn =0 - ref, 1 - fb*/
+static int get_in_pfd_ref_fb(struct i2c_client *client, int chn); /*chn =0,1 */
+static int set_in_frequency(struct i2c_client *client, u64 frequency,int src); /* 0 - 12, 1 - 3, 2 - 4, 3 - 5,6 */
+static u64 get_in_frequency(struct i2c_client *client,int src);
+
+
+static s64 read_multireg64 (struct i2c_client *client, const u32 * awe);
+static int write_multireg64 (struct i2c_client *client, u64 data, const u32 * awe);
+static int read_field (struct i2c_client *client, u32 awe);
+static int write_field (struct i2c_client *client, u8 data, u32 awe);
+static int write_adwe(struct i2c_client *client, u32 adwe);
+static int write_reg(struct i2c_client *client, u16 reg, u8 val, u8 mask);
+static int read_reg(struct i2c_client *client, u16 reg);
+
+
+/* raw access to i2c registers, need to set address (9 bits) first, then r/w data */
+static DEVICE_ATTR(address,      SYSFS_PERMISSIONS,  raw_address_show, raw_address_store);
+static DEVICE_ATTR(data,         SYSFS_PERMISSIONS,  raw_data_show,    raw_data_store);
+static DEVICE_ATTR(hex_address,  SYSFS_PERMISSIONS,  raw_hex_address_show, raw_hex_address_store);
+static DEVICE_ATTR(hex_data,     SYSFS_PERMISSIONS,  raw_hex_data_show,    raw_hex_data_store);
+static DEVICE_ATTR(hex_all,      SYSFS_PERMISSIONS & SYSFS_READONLY,  raw_hex_all_show,  NULL);
+static DEVICE_ATTR(hex_adwe,     SYSFS_PERMISSIONS,  raw_hex_adwe_show,  raw_hex_adwe_store);
+
+static struct attribute *raw_dev_attrs[] = {
+	&dev_attr_address.attr,
+	&dev_attr_data.attr,
+	&dev_attr_hex_address.attr,
+	&dev_attr_hex_data.attr,
+	&dev_attr_hex_all.attr,
+	&dev_attr_hex_adwe.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_raw_group = {
+	.attrs = raw_dev_attrs,
+	.name  = "raw",
+};
+
+
+//static DEVICE_ATTR(xtal_freq,    SYSFS_PERMISSIONS,  input_xtal_freq_show, input_xtal_freq_store);
+static DEVICE_ATTR(xtal_freq_txt, SYSFS_PERMISSIONS & SYSFS_READONLY,  input_xtal_freq_txt_show, NULL);
+static DEVICE_ATTR(in_frequency12,   SYSFS_PERMISSIONS,                   in_frequency12_show, in_frequency12_store);
+static DEVICE_ATTR(in_frequency3,   SYSFS_PERMISSIONS,                    in_frequency3_show,  in_frequency3_store);
+static DEVICE_ATTR(in_frequency4,   SYSFS_PERMISSIONS,                    in_frequency4_show,  in_frequency4_store);
+static DEVICE_ATTR(in_frequency56,   SYSFS_PERMISSIONS,                   in_frequency56_show, in_frequency56_store);
+static DEVICE_ATTR(in_p1_div,        SYSFS_PERMISSIONS,                   in_p1_div_show,   in_p1_div_store);
+static DEVICE_ATTR(in_p2_div,        SYSFS_PERMISSIONS,                   in_p2_div_show,   in_p2_div_store);
+static DEVICE_ATTR(in_mux,           SYSFS_PERMISSIONS,                   in_mux_show, in_mux_store);
+static DEVICE_ATTR(in_mux_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  in_mux_txt_show, NULL);
+static DEVICE_ATTR(fb_mux,           SYSFS_PERMISSIONS,                   fb_mux_show, fb_mux_store);
+static DEVICE_ATTR(fb_mux_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  fb_mux_txt_show, NULL);
+static DEVICE_ATTR(in_pfd_ref,       SYSFS_PERMISSIONS,                   in_pfd_ref_show, in_pfd_ref_store);
+static DEVICE_ATTR(in_pfd_ref_txt,   SYSFS_PERMISSIONS & SYSFS_READONLY,  in_pfd_ref_txt_show, NULL);
+static DEVICE_ATTR(in_pfd_fb,        SYSFS_PERMISSIONS,                   in_pfd_fb_show, in_pfd_fb_store);
+static DEVICE_ATTR(in_pfd_fb_txt,    SYSFS_PERMISSIONS & SYSFS_READONLY,  in_pfd_fb_txt_show, NULL);
+static DEVICE_ATTR(pll_ref_frequency,SYSFS_PERMISSIONS & SYSFS_READONLY,  pll_ref_frequency_show, NULL);
+
+
+static struct attribute *input_dev_attrs[] = {
+//	&dev_attr_xtal_freq.attr,
+	&dev_attr_xtal_freq_txt.attr,
+	&dev_attr_in_frequency12.attr,
+	&dev_attr_in_frequency3.attr,
+	&dev_attr_in_frequency4.attr,
+	&dev_attr_in_frequency56.attr,
+	&dev_attr_in_p1_div.attr,
+	&dev_attr_in_p2_div.attr,
+	&dev_attr_in_mux.attr,
+	&dev_attr_in_mux_txt.attr,
+	&dev_attr_fb_mux.attr,
+	&dev_attr_fb_mux_txt.attr,
+	&dev_attr_in_pfd_ref.attr,
+	&dev_attr_in_pfd_ref_txt.attr,
+	&dev_attr_in_pfd_fb.attr,
+	&dev_attr_in_pfd_fb_txt.attr,
+	&dev_attr_pll_ref_frequency.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_input_group = {
+	.attrs = input_dev_attrs,
+	.name  = "input",
+};
+
+static DEVICE_ATTR(ms0_p123, SYSFS_PERMISSIONS,  ms0_p123_show, ms0_p123_store);
+static DEVICE_ATTR(ms0_abc,  SYSFS_PERMISSIONS,  ms0_abc_show,  ms0_abc_store);
+static DEVICE_ATTR(ms1_p123, SYSFS_PERMISSIONS,  ms1_p123_show, ms1_p123_store);
+static DEVICE_ATTR(ms1_abc,  SYSFS_PERMISSIONS,  ms1_abc_show,  ms1_abc_store);
+static DEVICE_ATTR(ms2_p123, SYSFS_PERMISSIONS,  ms2_p123_show, ms2_p123_store);
+static DEVICE_ATTR(ms2_abc,  SYSFS_PERMISSIONS,  ms2_abc_show,  ms2_abc_store);
+static DEVICE_ATTR(ms3_p123, SYSFS_PERMISSIONS,  ms3_p123_show, ms3_p123_store);
+static DEVICE_ATTR(ms3_abc,  SYSFS_PERMISSIONS,  ms3_abc_show,  ms3_abc_store);
+static DEVICE_ATTR(msn_p123, SYSFS_PERMISSIONS,  msn_p123_show, msn_p123_store);
+static DEVICE_ATTR(msn_abc,  SYSFS_PERMISSIONS,  msn_abc_show,  msn_abc_store);
+static DEVICE_ATTR(ms0_powerdown,  SYSFS_PERMISSIONS,  ms0_powerdown_show,  ms0_powerdown_store);
+static DEVICE_ATTR(ms1_powerdown,  SYSFS_PERMISSIONS,  ms1_powerdown_show,  ms1_powerdown_store);
+static DEVICE_ATTR(ms2_powerdown,  SYSFS_PERMISSIONS,  ms2_powerdown_show,  ms2_powerdown_store);
+static DEVICE_ATTR(ms3_powerdown,  SYSFS_PERMISSIONS,  ms3_powerdown_show,  ms3_powerdown_store);
+
+static struct attribute *multisynth_attrs[] = {
+	&dev_attr_ms0_p123.attr,
+	&dev_attr_ms0_abc.attr,
+	&dev_attr_ms1_p123.attr,
+	&dev_attr_ms1_abc.attr,
+	&dev_attr_ms2_p123.attr,
+	&dev_attr_ms2_abc.attr,
+	&dev_attr_ms3_p123.attr,
+	&dev_attr_ms3_abc.attr,
+	&dev_attr_msn_p123.attr,
+	&dev_attr_msn_abc.attr,
+	&dev_attr_ms0_powerdown.attr,
+	&dev_attr_ms1_powerdown.attr,
+	&dev_attr_ms2_powerdown.attr,
+	&dev_attr_ms3_powerdown.attr,
+	NULL
+};
+static const struct attribute_group dev_attr_multisynth_group = {
+	.attrs = multisynth_attrs,
+	.name  = "multiSynth",
+};
+static DEVICE_ATTR(pll_freq_fract,  SYSFS_PERMISSIONS,  pll_freq_show,  pll_freq_fract_store);
+static DEVICE_ATTR(pll_freq_int,    SYSFS_PERMISSIONS,  pll_freq_show,  pll_freq_int_store);
+static DEVICE_ATTR(pll_by_out_fract,SYSFS_PERMISSIONS,  pll_freq_show,  pll_by_out_fract_store);
+static DEVICE_ATTR(pll_by_out_int,  SYSFS_PERMISSIONS,  pll_freq_show,  pll_by_out_int_store);
+
+
+static DEVICE_ATTR(pll_ms0_freq_fract,SYSFS_PERMISSIONS,  pll_ms0_freq_show,  pll_ms0_freq_fract_store);
+static DEVICE_ATTR(pll_ms0_freq_int,  SYSFS_PERMISSIONS,  pll_ms0_freq_show,  pll_ms0_freq_int_store);
+static DEVICE_ATTR(pll_ms1_freq_fract,SYSFS_PERMISSIONS,  pll_ms1_freq_show,  pll_ms1_freq_fract_store);
+static DEVICE_ATTR(pll_ms1_freq_int,  SYSFS_PERMISSIONS,  pll_ms1_freq_show,  pll_ms1_freq_int_store);
+static DEVICE_ATTR(pll_ms2_freq_fract,SYSFS_PERMISSIONS,  pll_ms2_freq_show,  pll_ms2_freq_fract_store);
+static DEVICE_ATTR(pll_ms2_freq_int,  SYSFS_PERMISSIONS,  pll_ms2_freq_show,  pll_ms2_freq_int_store);
+static DEVICE_ATTR(pll_ms3_freq_fract,SYSFS_PERMISSIONS,  pll_ms3_freq_show,  pll_ms3_freq_fract_store);
+static DEVICE_ATTR(pll_ms3_freq_int,  SYSFS_PERMISSIONS,  pll_ms3_freq_show,  pll_ms3_freq_int_store);
+
+
+static struct attribute *pll_dev_attrs[] = {
+	&dev_attr_pll_ref_frequency.attr,
+	&dev_attr_pll_freq_fract.attr,
+	&dev_attr_pll_freq_int.attr,
+	&dev_attr_pll_by_out_fract.attr,
+	&dev_attr_pll_by_out_int.attr,
+	&dev_attr_pll_ms0_freq_fract.attr,
+	&dev_attr_pll_ms0_freq_int.attr,
+	&dev_attr_pll_ms1_freq_fract.attr,
+	&dev_attr_pll_ms1_freq_int.attr,
+	&dev_attr_pll_ms2_freq_fract.attr,
+	&dev_attr_pll_ms2_freq_int.attr,
+	&dev_attr_pll_ms3_freq_fract.attr,
+	&dev_attr_pll_ms3_freq_int.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_pll_group = {
+	.attrs = pll_dev_attrs,
+	.name  = "pll",
+};
+
+static DEVICE_ATTR(out0_source,     SYSFS_PERMISSIONS,                   out0_source_show,     out0_source_store);
+static DEVICE_ATTR(out0_source_txt, SYSFS_PERMISSIONS & SYSFS_READONLY,  out0_source_txt_show, NULL);
+static DEVICE_ATTR(out1_source,     SYSFS_PERMISSIONS,                   out1_source_show,     out1_source_store);
+static DEVICE_ATTR(out1_source_txt, SYSFS_PERMISSIONS & SYSFS_READONLY,  out1_source_txt_show, NULL);
+static DEVICE_ATTR(out2_source,     SYSFS_PERMISSIONS,                   out2_source_show,     out2_source_store);
+static DEVICE_ATTR(out2_source_txt, SYSFS_PERMISSIONS & SYSFS_READONLY,  out2_source_txt_show, NULL);
+static DEVICE_ATTR(out3_source,     SYSFS_PERMISSIONS,                   out3_source_show,     out3_source_store);
+static DEVICE_ATTR(out3_source_txt, SYSFS_PERMISSIONS & SYSFS_READONLY,  out3_source_txt_show, NULL);
+static DEVICE_ATTR(out0_source_freq,SYSFS_PERMISSIONS & SYSFS_READONLY,  out0_source_freq_show, NULL);
+static DEVICE_ATTR(out1_source_freq,SYSFS_PERMISSIONS & SYSFS_READONLY,  out1_source_freq_show, NULL);
+static DEVICE_ATTR(out2_source_freq,SYSFS_PERMISSIONS & SYSFS_READONLY,  out2_source_freq_show, NULL);
+static DEVICE_ATTR(out3_source_freq,SYSFS_PERMISSIONS & SYSFS_READONLY,  out3_source_freq_show, NULL);
+
+static DEVICE_ATTR(out0_div,        SYSFS_PERMISSIONS,                   out0_div_show,     out0_div_store);
+static DEVICE_ATTR(out1_div,        SYSFS_PERMISSIONS,                   out1_div_show,     out1_div_store);
+static DEVICE_ATTR(out2_div,        SYSFS_PERMISSIONS,                   out2_div_show,     out2_div_store);
+static DEVICE_ATTR(out3_div,        SYSFS_PERMISSIONS,                   out3_div_show,     out3_div_store);
+
+static DEVICE_ATTR(out0_div_by_freq,SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,           out0_div_by_freq_store);
+static DEVICE_ATTR(out0_freq,       SYSFS_PERMISSIONS & SYSFS_READONLY,  out0_freq_show, NULL);
+static DEVICE_ATTR(out1_div_by_freq,SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,           out1_div_by_freq_store);
+static DEVICE_ATTR(out1_freq,       SYSFS_PERMISSIONS & SYSFS_READONLY,  out1_freq_show, NULL);
+static DEVICE_ATTR(out2_div_by_freq,SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,           out2_div_by_freq_store);
+static DEVICE_ATTR(out2_freq,       SYSFS_PERMISSIONS & SYSFS_READONLY,  out2_freq_show, NULL);
+static DEVICE_ATTR(out3_div_by_freq,SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,           out3_div_by_freq_store);
+static DEVICE_ATTR(out3_freq,       SYSFS_PERMISSIONS & SYSFS_READONLY,  out3_freq_show, NULL);
+
+static struct attribute *output_dev_attrs[] = {
+	&dev_attr_out0_source.attr,
+	&dev_attr_out0_source_txt.attr,
+	&dev_attr_out1_source.attr,
+	&dev_attr_out1_source_txt.attr,
+	&dev_attr_out2_source.attr,
+	&dev_attr_out2_source_txt.attr,
+	&dev_attr_out3_source.attr,
+	&dev_attr_out3_source_txt.attr,
+	&dev_attr_out0_source_freq.attr,
+	&dev_attr_out1_source_freq.attr,
+	&dev_attr_out2_source_freq.attr,
+	&dev_attr_out3_source_freq.attr,
+	&dev_attr_out0_div.attr,
+	&dev_attr_out1_div.attr,
+	&dev_attr_out2_div.attr,
+	&dev_attr_out3_div.attr,
+	&dev_attr_out0_div_by_freq.attr,
+	&dev_attr_out1_div_by_freq.attr,
+	&dev_attr_out2_div_by_freq.attr,
+	&dev_attr_out3_div_by_freq.attr,
+	&dev_attr_out0_freq.attr,
+	&dev_attr_out1_freq.attr,
+	&dev_attr_out2_freq.attr,
+	&dev_attr_out3_freq.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_output_group = {
+	.attrs = output_dev_attrs,
+	.name  = "output",
+};
+
+/* output drivers */
+
+static DEVICE_ATTR(drv0_powerdown,     SYSFS_PERMISSIONS,                   drv0_powerdown_show,      drv0_powerdown_store);
+static DEVICE_ATTR(drv1_powerdown,     SYSFS_PERMISSIONS,                   drv1_powerdown_show,      drv1_powerdown_store);
+static DEVICE_ATTR(drv2_powerdown,     SYSFS_PERMISSIONS,                   drv2_powerdown_show,      drv2_powerdown_store);
+static DEVICE_ATTR(drv3_powerdown,     SYSFS_PERMISSIONS,                   drv3_powerdown_show,      drv3_powerdown_store);
+
+static DEVICE_ATTR(drv0_disable,       SYSFS_PERMISSIONS,                   drv0_disable_show,        drv0_disable_store);
+static DEVICE_ATTR(drv1_disable,       SYSFS_PERMISSIONS,                   drv1_disable_show,        drv1_disable_store);
+static DEVICE_ATTR(drv2_disable,       SYSFS_PERMISSIONS,                   drv2_disable_show,        drv2_disable_store);
+static DEVICE_ATTR(drv3_disable,       SYSFS_PERMISSIONS,                   drv3_disable_show,        drv3_disable_store);
+
+static DEVICE_ATTR(drv0_disabled_state,SYSFS_PERMISSIONS,                   drv0_disabled_state_show, drv0_disabled_state_store);
+static DEVICE_ATTR(drv1_disabled_state,SYSFS_PERMISSIONS,                   drv1_disabled_state_show, drv1_disabled_state_store);
+static DEVICE_ATTR(drv2_disabled_state,SYSFS_PERMISSIONS,                   drv2_disabled_state_show, drv2_disabled_state_store);
+static DEVICE_ATTR(drv3_disabled_state,SYSFS_PERMISSIONS,                   drv3_disabled_state_show, drv3_disabled_state_store);
+
+static DEVICE_ATTR(drv0_invert,        SYSFS_PERMISSIONS,                   drv0_invert_show,         drv0_invert_store);
+static DEVICE_ATTR(drv1_invert,        SYSFS_PERMISSIONS,                   drv1_invert_show,         drv1_invert_store);
+static DEVICE_ATTR(drv2_invert,        SYSFS_PERMISSIONS,                   drv2_invert_show,         drv2_invert_store);
+static DEVICE_ATTR(drv3_invert,        SYSFS_PERMISSIONS,                   drv3_invert_show,         drv3_invert_store);
+
+static DEVICE_ATTR(drv0_invert_txt,    SYSFS_PERMISSIONS & SYSFS_READONLY,  drv0_invert_txt_show, NULL);
+static DEVICE_ATTR(drv1_invert_txt,    SYSFS_PERMISSIONS & SYSFS_READONLY,  drv1_invert_txt_show, NULL);
+static DEVICE_ATTR(drv2_invert_txt,    SYSFS_PERMISSIONS & SYSFS_READONLY,  drv2_invert_txt_show, NULL);
+static DEVICE_ATTR(drv3_invert_txt,    SYSFS_PERMISSIONS & SYSFS_READONLY,  drv3_invert_txt_show, NULL);
+
+static DEVICE_ATTR(drv0_type,          SYSFS_PERMISSIONS,                   drv0_type_show,           drv0_type_store);
+static DEVICE_ATTR(drv1_type,          SYSFS_PERMISSIONS,                   drv1_type_show,           drv1_type_store);
+static DEVICE_ATTR(drv2_type,          SYSFS_PERMISSIONS,                   drv2_type_show,           drv2_type_store);
+static DEVICE_ATTR(drv3_type,          SYSFS_PERMISSIONS,                   drv3_type_show,           drv3_type_store);
+
+static DEVICE_ATTR(drv0_type_txt,      SYSFS_PERMISSIONS & SYSFS_READONLY,  drv0_type_txt_show, NULL);
+static DEVICE_ATTR(drv1_type_txt,      SYSFS_PERMISSIONS & SYSFS_READONLY,  drv1_type_txt_show, NULL);
+static DEVICE_ATTR(drv2_type_txt,      SYSFS_PERMISSIONS & SYSFS_READONLY,  drv2_type_txt_show, NULL);
+static DEVICE_ATTR(drv3_type_txt,      SYSFS_PERMISSIONS & SYSFS_READONLY,  drv3_type_txt_show, NULL);
+
+static DEVICE_ATTR(drv0_vdd,           SYSFS_PERMISSIONS,                   drv0_vdd_show,            drv0_vdd_store);
+static DEVICE_ATTR(drv1_vdd,           SYSFS_PERMISSIONS,                   drv1_vdd_show,            drv1_vdd_store);
+static DEVICE_ATTR(drv2_vdd,           SYSFS_PERMISSIONS,                   drv2_vdd_show,            drv2_vdd_store);
+static DEVICE_ATTR(drv3_vdd,           SYSFS_PERMISSIONS,                   drv3_vdd_show,            drv3_vdd_store);
+
+static DEVICE_ATTR(drv0_vdd_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  drv0_vdd_txt_show, NULL);
+static DEVICE_ATTR(drv1_vdd_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  drv1_vdd_txt_show, NULL);
+static DEVICE_ATTR(drv2_vdd_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  drv2_vdd_txt_show, NULL);
+static DEVICE_ATTR(drv3_vdd_txt,       SYSFS_PERMISSIONS & SYSFS_READONLY,  drv3_vdd_txt_show, NULL);
+
+static DEVICE_ATTR(drv0_trim,          SYSFS_PERMISSIONS,                   drv0_trim_show,           drv0_trim_any_store);
+static DEVICE_ATTR(drv1_trim,          SYSFS_PERMISSIONS,                   drv1_trim_show,           drv1_trim_any_store);
+static DEVICE_ATTR(drv2_trim,          SYSFS_PERMISSIONS,                   drv2_trim_show,           drv2_trim_any_store);
+static DEVICE_ATTR(drv3_trim,          SYSFS_PERMISSIONS,                   drv3_trim_show,           drv3_trim_any_store);
+
+static DEVICE_ATTR(drv0_auto_trim,     SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,                     drv0_auto_trim_store);
+static DEVICE_ATTR(drv1_auto_trim,     SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,                     drv1_auto_trim_store);
+static DEVICE_ATTR(drv2_auto_trim,     SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,                     drv2_auto_trim_store);
+static DEVICE_ATTR(drv3_auto_trim,     SYSFS_PERMISSIONS & SYSFS_WRITEONLY, NULL,                     drv3_auto_trim_store);
+
+static DEVICE_ATTR(drv0_description,   SYSFS_PERMISSIONS & SYSFS_READONLY,  drv0_txt_show, NULL);
+static DEVICE_ATTR(drv1_description,   SYSFS_PERMISSIONS & SYSFS_READONLY,  drv1_txt_show, NULL);
+static DEVICE_ATTR(drv2_description,   SYSFS_PERMISSIONS & SYSFS_READONLY,  drv2_txt_show, NULL);
+static DEVICE_ATTR(drv3_description,   SYSFS_PERMISSIONS & SYSFS_READONLY,  drv3_txt_show, NULL);
+
+static struct attribute *output_drivers_dev_attrs[] = {
+	&dev_attr_drv0_powerdown.attr,
+	&dev_attr_drv1_powerdown.attr,
+	&dev_attr_drv2_powerdown.attr,
+	&dev_attr_drv3_powerdown.attr,
+
+	&dev_attr_drv0_disable.attr,
+	&dev_attr_drv1_disable.attr,
+	&dev_attr_drv2_disable.attr,
+	&dev_attr_drv3_disable.attr,
+
+	&dev_attr_drv0_disabled_state.attr,
+	&dev_attr_drv1_disabled_state.attr,
+	&dev_attr_drv2_disabled_state.attr,
+	&dev_attr_drv3_disabled_state.attr,
+
+	&dev_attr_drv0_invert.attr,
+	&dev_attr_drv1_invert.attr,
+	&dev_attr_drv2_invert.attr,
+	&dev_attr_drv3_invert.attr,
+
+	&dev_attr_drv0_invert_txt.attr,
+	&dev_attr_drv1_invert_txt.attr,
+	&dev_attr_drv2_invert_txt.attr,
+	&dev_attr_drv3_invert_txt.attr,
+
+	&dev_attr_drv0_type.attr,
+	&dev_attr_drv1_type.attr,
+	&dev_attr_drv2_type.attr,
+	&dev_attr_drv3_type.attr,
+
+	&dev_attr_drv0_type_txt.attr,
+	&dev_attr_drv1_type_txt.attr,
+	&dev_attr_drv2_type_txt.attr,
+	&dev_attr_drv3_type_txt.attr,
+
+	&dev_attr_drv0_vdd.attr,
+	&dev_attr_drv1_vdd.attr,
+	&dev_attr_drv2_vdd.attr,
+	&dev_attr_drv3_vdd.attr,
+
+	&dev_attr_drv0_vdd_txt.attr,
+	&dev_attr_drv1_vdd_txt.attr,
+	&dev_attr_drv2_vdd_txt.attr,
+	&dev_attr_drv3_vdd_txt.attr,
+
+	&dev_attr_drv0_trim.attr,
+	&dev_attr_drv1_trim.attr,
+	&dev_attr_drv2_trim.attr,
+	&dev_attr_drv3_trim.attr,
+
+	&dev_attr_drv0_auto_trim.attr,
+	&dev_attr_drv1_auto_trim.attr,
+	&dev_attr_drv2_auto_trim.attr,
+	&dev_attr_drv3_auto_trim.attr,
+
+	&dev_attr_drv0_description.attr,
+	&dev_attr_drv1_description.attr,
+	&dev_attr_drv2_description.attr,
+	&dev_attr_drv3_description.attr,
+	NULL
+};
+
+static const struct attribute_group dev_attr_output_drivers_group = {
+	.attrs = output_drivers_dev_attrs,
+	.name  = "output_drivers",
+};
+
+
+
+static int si5338_sysfs_register(struct device *dev)
+{
+//	struct i2c_client *client = to_i2c_client(dev);
+//	struct vsc330x_data_t *clientdata = i2c_get_clientdata(client);
+    int retval=0;
+    if (&dev->kobj) {
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_raw_group)))<0) return retval;
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_input_group)))<0) return retval;
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_multisynth_group)))<0) return retval;
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_pll_group)))<0) return retval;
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_output_group)))<0) return retval;
+    	if (((retval = sysfs_create_group(&dev->kobj, &dev_attr_output_drivers_group)))<0) return retval;
+    }
+    return retval;
+}
+
+
+
+static ssize_t raw_address_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct si5338_data_t *clientdata=i2c_get_clientdata(to_i2c_client(dev));
+    return sprintf(buf, "%d\n",clientdata->reg_addr);
+}
+static ssize_t raw_address_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct si5338_data_t *clientdata=i2c_get_clientdata(to_i2c_client(dev));
+    sscanf(buf, "%du", &clientdata->reg_addr);
+    return count;
+}
+
+static ssize_t raw_data_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	int data= read_reg(client, clientdata->reg_addr);
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t raw_data_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	int data;
+    sscanf(buf, "%du", &data);
+    write_reg(client, clientdata->reg_addr, data, 0xff); /* write all register, it is up to user to do R-mod-W */
+    return count;
+}
+
+static ssize_t raw_hex_address_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct si5338_data_t *clientdata=i2c_get_clientdata(to_i2c_client(dev));
+    return sprintf(buf, "0x%03x\n",clientdata->reg_addr);
+}
+static ssize_t raw_hex_address_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct si5338_data_t *clientdata=i2c_get_clientdata(to_i2c_client(dev));
+    sscanf(buf, "%x", &clientdata->reg_addr);
+    return count;
+}
+
+static ssize_t raw_hex_data_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	int data= read_reg(client, clientdata->reg_addr);
+    return sprintf(buf, "0x%02x\n",data);
+}
+static ssize_t raw_hex_data_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	int data;
+    sscanf(buf, "%x", &data);
+    write_reg(client, clientdata->reg_addr, data, 0xff); /* write all register, it is up to user to do R-mod-W */
+    return count;
+}
+
+static ssize_t raw_hex_all_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int low_addr=0,reg,data,rc,len=0, count=PAGE_SIZE;
+	struct i2c_client *client =       to_i2c_client(dev);
+//	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	for (reg=low_addr;reg<=LAST_REG;reg++) if (count>10){
+		if ((reg & 0xf) ==0){
+			rc=sprintf(buf, "%03x: ",reg);
+		    buf+=rc;
+		    len+=rc;
+		    count-=rc;
+		}
+		if (((data= read_reg(client, reg)))<0) return data;
+		rc=sprintf(buf, "%02x",data);
+	    buf+=rc;
+	    len+=rc;
+	    count-=rc;
+		if (((reg & 0xf) == 0xf) || (reg==LAST_REG)){
+			rc=sprintf(buf, "\n");
+		} else {
+			rc=sprintf(buf, " ");
+		}
+	    buf+=rc;
+	    len+=rc;
+	    count-=rc;
+	}
+	return len;
+}
+static ssize_t raw_hex_adwe_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf,"Write only, provide single or multiple hex values in the form [0x]AAADDWW, where AAA is register address\n" \
+			            "DD - data byte and WW - write enable bits ( 1 - write, 0 - keep old)\n");
+
+}
+/*
+ *  accepts single or multiple data, each [0x]AAADDWW - AAA - register address, DD - data byte, WW - write enable mask (1 - write, 0 - keep).
+ *  Ignores any other characters, so same format as in dts with hex data is OK
+ */
+static ssize_t raw_hex_adwe_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	const char digits[]="0123456789";
+	struct i2c_client *client =       to_i2c_client(dev);
+	struct si5338_data_t *clientdata= i2c_get_clientdata(client);
+	int adwe,rc=0;
+	int left=count,num_bytes;
+	const char * cp;
+ 	mutex_lock(&clientdata->lock);
+	while ((left>0) && ((cp=strpbrk(buf,digits))) && cp[0]){
+		left -= (cp-buf);
+		buf = cp;
+		dev_dbg(dev,"left=%d", left);
+	    sscanf(buf, "%x%n", &adwe,&num_bytes);
+	    left-=num_bytes;
+	    buf+=num_bytes;
+	    dev_dbg(dev,"left=%d num_bytes=%d, adwe=0x%08x", left,num_bytes,adwe);
+	    if (((rc=write_adwe(client, adwe)))<0) {
+	    	mutex_unlock(&clientdata->lock);
+	    	return rc;
+	    }
+	}
+	mutex_unlock(&clientdata->lock);
+    return count;
+}
+
+static ssize_t input_xtal_freq_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *txt[]= {"8MHz..11Mhz", "11MHz..19Mhz", "19MHz..26Mhz", "26MHz..30Mhz"};
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data= read_field (client, AWE_XTAL_FREQ);
+    return sprintf(buf, "%s\n",(data>=0)?txt[data]:"error");
+}
+
+
+static ssize_t in_frequency12_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	s64 freq= get_in_frequency (client,0);
+	if (freq<0) return -EINVAL;
+    return sprintf(buf, "%lld\n",freq);
+}
+static ssize_t in_frequency3_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	s64 freq= get_in_frequency (client,1);
+	if (freq<0) return -EINVAL;
+    return sprintf(buf, "%lld\n",freq);
+}
+static ssize_t in_frequency4_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	s64 freq= get_in_frequency (client,2);
+	if (freq<0) return -EINVAL;
+    return sprintf(buf, "%lld\n",freq);
+}
+static ssize_t in_frequency56_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	s64 freq= get_in_frequency (client,3);
+	if (freq<0) return -EINVAL;
+    return sprintf(buf, "%lld\n",freq);
+}
+static ssize_t in_frequency12_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	u64 freq;
+	struct i2c_client *client =       to_i2c_client(dev);
+    sscanf(buf, "%lld", &freq);
+    if (((rc=set_in_frequency (client, freq,0)))<0) return rc;
+    return count;
+}
+static ssize_t in_frequency3_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	u64 freq;
+	struct i2c_client *client =       to_i2c_client(dev);
+    sscanf(buf, "%lld", &freq);
+    if (((rc=set_in_frequency (client, freq,1)))<0) return rc;
+    return count;
+}
+static ssize_t in_frequency4_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	u64 freq;
+	struct i2c_client *client =       to_i2c_client(dev);
+    sscanf(buf, "%lld", &freq);
+    if (((rc=set_in_frequency (client, freq,2)))<0) return rc;
+    return count;
+}
+static ssize_t in_frequency56_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	u64 freq;
+	struct i2c_client *client =       to_i2c_client(dev);
+    sscanf(buf, "%lld", &freq);
+    if (((rc=set_in_frequency (client, freq,3)))<0) return rc;
+    return count;
+}
+
+static ssize_t _in_p12_div_show (struct device *dev, struct device_attribute *attr, char *buf,  int chn)
+{
+	int div;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((div=get_in_pdiv(client,chn)))<0) return div;
+    return sprintf(buf, "%d\n",div);
+}
+static ssize_t _in_p12_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int div,rc;
+    sscanf(buf, "%d", &div);
+    if (((rc=set_in_pdiv(client, div,chn)))<0) return rc;
+    return count;
+}
+
+static ssize_t in_p1_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return _in_p12_div_show (dev, attr, buf, 0);
+}
+static ssize_t in_p1_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	return _in_p12_div_store(dev, attr, buf, count, 0);
+}
+
+static ssize_t in_p2_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return _in_p12_div_show (dev, attr, buf, 1);
+}
+static ssize_t in_p2_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	return _in_p12_div_store(dev, attr, buf, count, 1);
+}
+
+static ssize_t in_mux_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_mux(client)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t in_mux_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_in_mux(client, data)))<0) return rc;
+    return count;
+}
+static ssize_t in_mux_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *mux_txt[]={"IN1/IN2(diff)","IN3(single ended)","IN1/IN2(xtal)"};
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_mux(client)))<0) return data;
+    return sprintf(buf, "%s\n",mux_txt[data]);
+}
+static ssize_t fb_mux_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_fb_mux(client)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t fb_mux_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_fb_mux(client, data)))<0) return rc;
+    return count;
+}
+static ssize_t fb_mux_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *mux_fb_txt[]={"IN5/IN6(diff)","IN4(single ended)","No clock"};
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_fb_mux(client)))<0) return data;
+    return sprintf(buf, "%s\n",mux_fb_txt[data]);
+}
+
+static ssize_t in_pfd_ref_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_pfd_ref_fb(client,0)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t in_pfd_ref_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_in_pfd_ref_fb(client, data,0)))<0) return rc;
+    return count;
+}
+static ssize_t in_pfd_ref_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *pfd_ref_txt[]={"p1div_in(refclk)","p2div_in(fbclk)","p1div_out(refclk)","p2div_out(fbclk)","xoclk","noclk"};
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_pfd_ref_fb(client,0)))<0) return data;
+    return sprintf(buf, "%s\n",pfd_ref_txt[data]);
+}
+
+static ssize_t in_pfd_fb_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_pfd_ref_fb(client,1)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t in_pfd_fb_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_in_pfd_ref_fb(client, data,1)))<0) return rc;
+    return count;
+}
+static ssize_t in_pfd_fb_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	const char *pfd_fb_txt[]={"p2div_in(fbclk)","p1div_in(refclk)","p2div_out(fbclk)","p1div_out(refclk)","reserved","noclk"};
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_in_pfd_ref_fb(client,1)))<0) return data;
+    return sprintf(buf, "%s\n",pfd_fb_txt[data]);
+}
+
+static ssize_t pll_ref_frequency_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	s64 pll_in_freq= get_pll_in_frequency(client);
+	if (pll_in_freq<0) return (int) pll_in_freq;
+    return sprintf(buf, "%lld\n",pll_in_freq);
+}
+static ssize_t _msx_p123_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int rc;
+	u32 p123[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((rc=get_ms_p123(client,p123, chn)))<0) return rc;
+//    return sprintf(buf, "%ld %ld %ld\n",p123[0],p123[1],p123[2]);
+    return sprintf(buf, "%u %u %u\n",p123[0],p123[1],p123[2]);
+}
+static ssize_t _msx_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	u32 p123[3];
+	int num_items;
+//	num_items=sscanf(buf, "%ld %ld %ld", &p123[0], &p123[1], &p123[2]);
+	num_items=sscanf(buf, "%u %u %u", &p123[0], &p123[1], &p123[2]);
+	if (num_items<3){
+		p123[1]=0;
+		p123[2]=1;
+	}
+	if (((rc=set_ms_p123(client,p123, chn)))<0) return rc;
+    return count;
+}
+static ssize_t _msx_abc_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int rc;
+	u32 p123[3];
+	u64 ms[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((rc=get_ms_p123(client,p123, chn)))<0) return rc;
+	p123_to_ms(ms,p123);
+    return sprintf(buf, "%lld %lld %lld\n",ms[0],ms[1],ms[2]);
+}
+static ssize_t _msx_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	u32 p123[3];
+	u64 ms[3];
+	int num_items;
+	num_items=sscanf(buf, "%lld %lld %lld", &ms[0], &ms[1], &ms[2]);
+	if (num_items<3){
+		ms[1]=0;
+		ms[2]=1;
+	}
+	ms_to_p123(ms,p123);
+	if (((rc=set_ms_p123(client,p123, chn)))<0) return rc;
+    return count;
+}
+static ssize_t ms0_p123_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_p123_show(dev, attr, buf, 0);}
+static ssize_t ms0_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_p123_store(dev, attr, buf, count,0);}
+static ssize_t ms0_abc_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_abc_show(dev, attr, buf, 0);}
+static ssize_t ms0_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_abc_store(dev, attr, buf, count,0);}
+
+static ssize_t ms1_p123_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_p123_show(dev, attr, buf, 1);}
+static ssize_t ms1_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_p123_store(dev, attr, buf, count,1);}
+static ssize_t ms1_abc_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_abc_show(dev, attr, buf, 1);}
+static ssize_t ms1_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_abc_store(dev, attr, buf, count,1);}
+
+static ssize_t ms2_p123_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_p123_show(dev, attr, buf, 2);}
+static ssize_t ms2_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_p123_store(dev, attr, buf, count,2);}
+static ssize_t ms2_abc_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_abc_show(dev, attr, buf, 2);}
+static ssize_t ms2_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_abc_store(dev, attr, buf, count,2);}
+
+static ssize_t ms3_p123_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_p123_show(dev, attr, buf, 3);}
+static ssize_t ms3_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_p123_store(dev, attr, buf, count,3);}
+static ssize_t ms3_abc_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_abc_show(dev, attr, buf, 3);}
+static ssize_t ms3_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_abc_store(dev, attr, buf, count,3);}
+static ssize_t msn_p123_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_p123_show(dev, attr, buf, 4);}
+static ssize_t msn_p123_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_p123_store(dev, attr, buf, count,4);}
+static ssize_t msn_abc_show(struct device *dev, struct device_attribute *attr, char *buf)
+	{return _msx_abc_show(dev, attr, buf, 4);}
+static ssize_t msn_abc_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _msx_abc_store(dev, attr, buf, count,4);}
+static ssize_t _ms_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_ms_powerdown(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _ms_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_ms_powerdown(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t ms0_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _ms_powerdown_show (dev, attr, buf, 0); }
+static ssize_t ms1_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _ms_powerdown_show (dev, attr, buf, 1); }
+static ssize_t ms2_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _ms_powerdown_show (dev, attr, buf, 2); }
+static ssize_t ms3_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _ms_powerdown_show (dev, attr, buf, 3); }
+static ssize_t ms0_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _ms_powerdown_store(dev, attr, buf,count, 0);}
+static ssize_t ms1_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _ms_powerdown_store(dev, attr, buf,count, 1);}
+static ssize_t ms2_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _ms_powerdown_store(dev, attr, buf,count, 2);}
+static ssize_t ms3_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _ms_powerdown_store(dev, attr, buf,count, 3);}
+
+static ssize_t pll_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rc;
+	u64 pll_freq[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+
+	if (((rc=get_pll_freq(client,pll_freq)))<0) return rc;
+    return sprintf(buf, "%lld %lld %lld\n",pll_freq[0],pll_freq[1],pll_freq[2]);
+}
+
+static ssize_t _pll_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int int_div, int by_out)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	u64 freq[3];
+	int num_items;
+	num_items=sscanf(buf, "%lld %lld %lld", &freq[0], &freq[1], &freq[2]);
+	if (num_items<3){
+		freq[1]=0;
+		freq[2]=1;
+	}
+	if (by_out) {
+		if (((rc=set_pll_freq_by_out(client, freq, int_div)))<0) return rc;
+		if (((rc=set_pll_paremeters(client)))<0) return rc;
+		if (((rc=set_misc_registers(client)))<0) return rc;
+
+	} else {
+		if (((rc=set_pll_freq       (client, freq, int_div)))<0) return rc;
+		if (((rc=set_pll_paremeters(client)))<0) return rc;
+		if (((rc=set_misc_registers(client)))<0) return rc;
+	}
+    return count;
+}
+static ssize_t pll_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _pll_freq_store(dev, attr, buf, count, 0, 0);}
+static ssize_t pll_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _pll_freq_store(dev, attr, buf, count, 1, 0);}
+static ssize_t pll_by_out_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _pll_freq_store(dev, attr, buf, count, 0, 1);}
+static ssize_t pll_by_out_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+	{return _pll_freq_store(dev, attr, buf, count, 1, 1);}
+
+static ssize_t _pll_ms_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int rc;
+	u64 ms_freq[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+
+	if (((rc=get_pll_ms_freq(client, ms_freq, chn)))<0) return rc;
+    return sprintf(buf, "%lld %lld %lld\n",ms_freq[0],ms_freq[1],ms_freq[2]);
+}
+static ssize_t _pll_ms_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count,int int_div, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	u64 freq[3];
+	int num_items;
+	num_items=sscanf(buf, "%lld %lld %lld", &freq[0], &freq[1], &freq[2]);
+	if (num_items<3){
+		freq[1]=0;
+		freq[2]=1;
+	}
+	if (((rc=set_pll_ms_by_out(client, freq, chn, int_div)))<0) return rc;
+    return count;
+}
+static ssize_t pll_ms0_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _pll_ms_freq_show(dev, attr, buf, 0);}
+static ssize_t pll_ms1_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _pll_ms_freq_show(dev, attr, buf, 1);}
+static ssize_t pll_ms2_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _pll_ms_freq_show(dev, attr, buf, 2);}
+static ssize_t pll_ms3_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _pll_ms_freq_show(dev, attr, buf, 3);}
+static ssize_t pll_ms0_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 0, 0);}
+static ssize_t pll_ms1_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 0, 1);}
+static ssize_t pll_ms2_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 0, 2);}
+static ssize_t pll_ms3_freq_fract_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 0, 3);}
+static ssize_t pll_ms0_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 1, 0);}
+static ssize_t pll_ms1_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 1, 1);}
+static ssize_t pll_ms2_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 1, 2);}
+static ssize_t pll_ms3_freq_int_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _pll_ms_freq_store(dev, attr, buf, count, 1, 3);}
+
+/* -----------Output section--------------------------- */
+static ssize_t _out_source_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int out_src;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((out_src=get_out_source(client, chn)))<0) return out_src;
+    return sprintf(buf, "%d\n",out_src);
+}
+static ssize_t _out_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	int out_src;
+	sscanf(buf, "%d", &out_src);
+	if (((rc=set_out_source(client, chn, out_src)))<0) return rc;
+    return count;
+}
+static ssize_t _out_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int out_src;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((out_src=get_out_source(client, chn)))<0) return out_src;
+	switch (out_src){
+	case 0: return sprintf(buf, "p2div_in\n");
+	case 1: return sprintf(buf, "p1div_in\n");
+	case 2: return sprintf(buf, "p2div_out\n");
+	case 3: return sprintf(buf, "p1div_out\n");
+	case 4: return sprintf(buf, "xoclk\n");
+	case 5: return sprintf(buf, "MS0\n");
+	case 6: return sprintf(buf, "MS%d\n",chn);
+	case 7: return sprintf(buf, "No clock\n");
+	}
+    return -EINVAL;
+}
+
+static ssize_t _out_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int rc;
+	u64 out_source_freq[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+
+	if (((rc=get_output_src_frequency(client, out_source_freq, chn)))<0) return rc;
+    return sprintf(buf, "%lld %lld %lld\n",out_source_freq[0],out_source_freq[1],out_source_freq[2]);
+}
+
+static ssize_t out0_source_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_show(dev, attr, buf, 0);}
+static ssize_t out1_source_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_show(dev, attr, buf, 1);}
+static ssize_t out2_source_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_show(dev, attr, buf, 2);}
+static ssize_t out3_source_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_show(dev, attr, buf, 3);}
+
+static ssize_t out0_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _out_source_store(dev, attr, buf, count, 0);}
+static ssize_t out1_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _out_source_store(dev, attr, buf, count, 1);}
+static ssize_t out2_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _out_source_store(dev, attr, buf, count, 2);}
+static ssize_t out3_source_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _out_source_store(dev, attr, buf, count, 3);}
+
+static ssize_t out0_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_txt_show(dev, attr, buf, 0);}
+static ssize_t out1_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_txt_show(dev, attr, buf, 1);}
+static ssize_t out2_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_txt_show(dev, attr, buf, 2);}
+static ssize_t out3_source_txt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_txt_show(dev, attr, buf, 3);}
+
+static ssize_t out0_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_freq_show(dev, attr, buf, 0);}
+static ssize_t out1_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_freq_show(dev, attr, buf, 1);}
+static ssize_t out2_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_freq_show(dev, attr, buf, 2);}
+static ssize_t out3_source_freq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{return _out_source_freq_show(dev, attr, buf, 3);}
+
+static ssize_t _out_div_show (struct device *dev, struct device_attribute *attr, char *buf,  int chn)
+{
+	int div;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((div=get_out_div(client,chn)))<0) return div;
+    return sprintf(buf, "%d\n",div);
+}
+static ssize_t _out_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int div,rc;
+    sscanf(buf, "%d", &div);
+    if (((rc=set_out_div(client, div,chn)))<0) return rc;
+    return count;
+}
+static ssize_t out0_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_div_show (dev, attr, buf, 0);}
+static ssize_t out1_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_div_show (dev, attr, buf, 1);}
+static ssize_t out2_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_div_show (dev, attr, buf, 2);}
+static ssize_t out3_div_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_div_show (dev, attr, buf, 3);}
+static ssize_t out0_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_store(dev, attr, buf, count, 0);}
+static ssize_t out1_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_store(dev, attr, buf, count, 1);}
+static ssize_t out2_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_store(dev, attr, buf, count, 2);}
+static ssize_t out3_div_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_store(dev, attr, buf, count, 3);}
+//static int set_out_div_by_frequency(struct i2c_client *client, u64* out_freq, int chn); /*chn =0..3 */
+
+static ssize_t _out_freq_show(struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int rc;
+	u64 out_freq[3];
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((rc=get_out_frequency(client, out_freq, chn)))<0) return rc;
+    return sprintf(buf, "%lld %lld %lld\n",out_freq[0],out_freq[1],out_freq[2]);
+}
+static ssize_t _out_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int rc;
+	u64 freq[3];
+	int num_items;
+	num_items=sscanf(buf, "%lld %lld %lld", &freq[0], &freq[1], &freq[2]);
+	if (num_items<3){
+		freq[1]=0;
+		freq[2]=1;
+	}
+	if (((rc=set_out_div_by_frequency(client, freq, chn)))<0) return rc;
+	return count;
+}
+static ssize_t out0_freq_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_freq_show (dev, attr, buf, 0);}
+static ssize_t out1_freq_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_freq_show (dev, attr, buf, 1);}
+static ssize_t out2_freq_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_freq_show (dev, attr, buf, 2);}
+static ssize_t out3_freq_show (struct device *dev, struct device_attribute *attr, char *buf)
+{ return _out_freq_show (dev, attr, buf, 3);}
+static ssize_t out0_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_by_freq_store(dev, attr, buf, count, 0);}
+static ssize_t out1_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_by_freq_store(dev, attr, buf, count, 1);}
+static ssize_t out2_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_by_freq_store(dev, attr, buf, count, 2);}
+static ssize_t out3_div_by_freq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ return _out_div_by_freq_store(dev, attr, buf, count, 3);}
+
+
+static ssize_t _drv_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_powerdown(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_powerdown(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_powerdown_show (dev, attr, buf, 0); }
+static ssize_t drv1_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_powerdown_show (dev, attr, buf, 1); }
+static ssize_t drv2_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_powerdown_show (dev, attr, buf, 2); }
+static ssize_t drv3_powerdown_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_powerdown_show (dev, attr, buf, 3); }
+static ssize_t drv0_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_powerdown_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_powerdown_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_powerdown_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_powerdown_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_powerdown_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_disable_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_disable(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_disable(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_disable_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disable_show (dev, attr, buf, 0); }
+static ssize_t drv1_disable_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disable_show (dev, attr, buf, 1); }
+static ssize_t drv2_disable_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disable_show (dev, attr, buf, 2); }
+static ssize_t drv3_disable_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disable_show (dev, attr, buf, 3); }
+static ssize_t drv0_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disable_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disable_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disable_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_disable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disable_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_disabled_state(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_disabled_state(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disabled_state_show (dev, attr, buf, 0); }
+static ssize_t drv1_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disabled_state_show (dev, attr, buf, 1); }
+static ssize_t drv2_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disabled_state_show (dev, attr, buf, 2); }
+static ssize_t drv3_disabled_state_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_disabled_state_show (dev, attr, buf, 3); }
+static ssize_t drv0_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disabled_state_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disabled_state_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disabled_state_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_disabled_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_disabled_state_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_invert_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_invert(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_invert(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_show (dev, attr, buf, 0); }
+static ssize_t drv1_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_show (dev, attr, buf, 1); }
+static ssize_t drv2_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_show (dev, attr, buf, 2); }
+static ssize_t drv3_invert_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_show (dev, attr, buf, 3); }
+static ssize_t drv0_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_invert_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_invert_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_invert_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_invert_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_invert(client,chn)))<0) return data;
+	switch (data) {
+	case 0:return sprintf(buf, "No inversion\n");
+	case 1:return sprintf(buf, "Invert A only (CMOS/SSTL,HSTL)\n");
+	case 2:return sprintf(buf, "Invert B only (CMOS/SSTL,HSTL)\n");
+	case 3:return sprintf(buf, "Invert both A and B (CMOS/SSTL,HSTL)\n");
+	}
+    return 0; /* never */
+}
+static ssize_t drv0_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_txt_show (dev, attr, buf, 0); }
+static ssize_t drv1_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_txt_show (dev, attr, buf, 1); }
+static ssize_t drv2_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_txt_show (dev, attr, buf, 2); }
+static ssize_t drv3_invert_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_invert_txt_show (dev, attr, buf, 3); }
+
+
+
+static ssize_t _drv_type_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_type(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_type(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_type_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_show (dev, attr, buf, 0); }
+static ssize_t drv1_type_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_show (dev, attr, buf, 1); }
+static ssize_t drv2_type_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_show (dev, attr, buf, 2); }
+static ssize_t drv3_type_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_show (dev, attr, buf, 3); }
+static ssize_t drv0_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_type_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_type_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_type_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_type_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_type_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_type(client,chn)))<0) return data;
+	switch (data) {
+	case 0:return sprintf(buf, "reserved\n");
+	case 1:return sprintf(buf, "CMOS/SSTL/HSTL A enabled, B disabled\n");
+	case 2:return sprintf(buf, "CMOS/SSTL/HSTL A disabled, A enabled\n");
+	case 3:return sprintf(buf, "CMOS/SSTL/HSTL A enabled, B enabled\n");
+	case 4:return sprintf(buf, "LVPECL\n");
+	case 5:return sprintf(buf, "LVDS\n");
+	case 6:return sprintf(buf, "CML\n");
+	case 7:return sprintf(buf, "HCSL\n");
+	}
+    return 0; /* never */
+}
+static ssize_t drv0_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_txt_show (dev, attr, buf, 0); }
+static ssize_t drv1_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_txt_show (dev, attr, buf, 1); }
+static ssize_t drv2_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_txt_show (dev, attr, buf, 2); }
+static ssize_t drv3_type_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_type_txt_show (dev, attr, buf, 3); }
+
+static ssize_t _drv_vdd_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_vdd(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t _drv_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_vdd(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_vdd_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_show (dev, attr, buf, 0); }
+static ssize_t drv1_vdd_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_show (dev, attr, buf, 1); }
+static ssize_t drv2_vdd_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_show (dev, attr, buf, 2); }
+static ssize_t drv3_vdd_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_show (dev, attr, buf, 3); }
+static ssize_t drv0_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_vdd_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_vdd_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_vdd_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_vdd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_vdd_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_vdd(client,chn)))<0) return data;
+	switch (data) {
+	case 0:return sprintf(buf, "3.3V\n");
+	case 1:return sprintf(buf, "2.5V\n");
+	case 2:return sprintf(buf, "1.8V\n");
+	case 3:return sprintf(buf, "1.5V\n");
+	}
+    return 0; /* never */
+}
+static ssize_t drv0_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_txt_show (dev, attr, buf, 0); }
+static ssize_t drv1_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_txt_show (dev, attr, buf, 1); }
+static ssize_t drv2_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_txt_show (dev, attr, buf, 2); }
+static ssize_t drv3_vdd_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_vdd_txt_show (dev, attr, buf, 3); }
+
+static ssize_t _drv_trim_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	int data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_trim(client,chn)))<0) return data;
+    return sprintf(buf, "%d\n",data);
+}
+static ssize_t drv0_trim_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_trim_show (dev, attr, buf, 0); }
+static ssize_t drv1_trim_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_trim_show (dev, attr, buf, 1); }
+static ssize_t drv2_trim_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_trim_show (dev, attr, buf, 2); }
+static ssize_t drv3_trim_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_trim_show (dev, attr, buf, 3); }
+
+static ssize_t _update_drv_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=update_drv_trim(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _update_drv_trim_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _update_drv_trim_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _update_drv_trim_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_auto_trim_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _update_drv_trim_store(dev, attr, buf,count, 3);}
+static ssize_t _drv_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int chn)
+{
+	struct i2c_client *client =       to_i2c_client(dev);
+	int data,rc;
+	sscanf(buf, "%d", &data);
+    if (((rc=set_drv_trim_any(client, data, chn)))<0) return rc;
+    return count;
+}
+static ssize_t drv0_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_trim_any_store(dev, attr, buf,count, 0);}
+static ssize_t drv1_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_trim_any_store(dev, attr, buf,count, 1);}
+static ssize_t drv2_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_trim_any_store(dev, attr, buf,count, 2);}
+static ssize_t drv3_trim_any_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{return _drv_trim_any_store(dev, attr, buf,count, 3);}
+
+static ssize_t _drv_txt_show (struct device *dev, struct device_attribute *attr, char *buf, int chn)
+{
+	char * data;
+	struct i2c_client *client =       to_i2c_client(dev);
+	if (((data=get_drv_txt(client,chn)))==NULL) return -EINVAL;
+    return sprintf(buf, "%s\n",data);
+}
+static ssize_t drv0_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_txt_show (dev, attr, buf, 0); }
+static ssize_t drv1_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_txt_show (dev, attr, buf, 1); }
+static ssize_t drv2_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_txt_show (dev, attr, buf, 2); }
+static ssize_t drv3_txt_show (struct device *dev, struct device_attribute *attr, char *buf)
+{return _drv_txt_show (dev, attr, buf, 3); }
+
+/* -----------Output section--------------------------- */
+
+static const u32 awe_rdiv_in[]=  {AWE_R0DIV_IN,AWE_R1DIV_IN,AWE_R1DIV_IN,AWE_R1DIV_IN};
+static const u32 awe_rdiv_k[]=   {AWE_R0DIV,   AWE_R1DIV,   AWE_R1DIV,   AWE_R1DIV};
+static const u32 awe_drv_fmt[]=  {AWE_DRV0_FMT, AWE_DRV1_FMT,AWE_DRV2_FMT,AWE_DRV3_FMT};
+static const u32 awe_drv_vddo[]= {AWE_DRV0_VDDO, AWE_DRV1_VDDO, AWE_DRV2_VDDO, AWE_DRV3_VDDO};
+static const u32 awe_drv_trim[][4]= {{AWE_DRV0_TRIM,0,0}, {AWE_DRV1_TRIM_A,AWE_DRV1_TRIM_B,0},{AWE_DRV2_TRIM,0,0},{AWE_DRV3_TRIM,0,0}};
+static const u32 awe_drv_powerdown[]={AWE_DRV0_PDN, AWE_DRV1_PDN, AWE_DRV2_PDN, AWE_DRV2_PDN};
+static const u32 awe_drv_disable[]={AWE_OUT0_DIS, AWE_OUT1_DIS, AWE_OUT2_DIS, AWE_OUT3_DIS, AWE_OUT_ALL_DIS};
+static const u32 awe_drv_dis_state[]={AWE_OUT0_DIS_STATE, AWE_OUT1_DIS_STATE, AWE_OUT2_DIS_STATE, AWE_OUT3_DIS_STATE};
+static const u32 awe_drv_invert[]={AWE_DRV0_INV, AWE_DRV1_INV, AWE_DRV1_INV, AWE_DRV3_INV};
+
+
+
+
+static const u32 awe_drv_inv[]=  {AWE_DRV0_INV, AWE_DRV1_INV, AWE_DRV2_INV, AWE_DRV3_INV};
+
+
+static const u8 out_div_values[]={1,2,4,8,16,32};
+static int _verify_output_channel(struct i2c_client *client,int chn)
+{
+	if ((chn<0) || (chn>3)){
+		dev_err(&client->dev, "Invalid output channel: %d (only 0..3 are allowed)\n",chn);
+		return - EINVAL;
+	}
+	return 0;
+}
+
+static int get_drv_powerdown(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_powerdown[chn]);
+}
+
+static int set_drv_powerdown(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if (typ) typ=1;
+	return write_field (client, (u8) typ, awe_drv_powerdown[chn]);
+}
+
+static int get_drv_disable(struct i2c_client *client, int chn)
+{
+	int rc;
+	if ((chn!=4) && (((rc=_verify_output_channel(client,chn)))<0)) return rc;
+	return read_field (client, awe_drv_disable[chn]);
+}
+
+static int set_drv_disable(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if ((chn!=4) && (((rc=_verify_output_channel(client,chn)))<0)) return rc;
+	if (typ) typ=1;
+	return write_field (client, (u8) typ, awe_drv_disable[chn]);
+}
+
+
+static int get_drv_disabled_state(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_dis_state[chn]);
+}
+
+static int set_drv_disabled_state(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((typ<0) || (typ>3)){
+		dev_err(&client->dev, "Invalid disabled state %d. Only 0..3 are supported\n",typ);
+		return - EINVAL;
+	}
+	return write_field (client, (u8) typ, awe_drv_dis_state[chn]);
+}
+
+static int get_drv_invert(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_invert[chn]);
+}
+
+static int set_drv_invert(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((typ<0) || (typ>3)){
+		dev_err(&client->dev, "Invalid invert drivers %d. Only 0..3 are supported\n",typ);
+		return - EINVAL;
+	}
+	return write_field (client, (u8) typ, awe_drv_invert[chn]);
+}
+
+static int get_drv_type(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_fmt[chn]);
+}
+
+static int set_drv_type(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((typ<0) || (typ>7)){
+		dev_err(&client->dev, "Invalid output type %d. Only 0..7 are supported\n",typ);
+		return - EINVAL;
+	}
+	return write_field (client, (u8) typ, awe_drv_fmt[chn]);
+}
+static int get_drv_vdd(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_vddo[chn]);
+}
+
+static int set_drv_vdd(struct i2c_client *client, int vdd, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((vdd<0) || (vdd>7)){
+		dev_err(&client->dev, "Invalid output type %d. Only 0..3 are supported\n",vdd);
+		return - EINVAL;
+	}
+	return write_field (client, (u8) vdd, awe_drv_vddo[chn]);
+}
+static int get_drv_trim(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return (int) read_multireg64 (client, awe_drv_trim[chn]);
+}
+/* uses out_type and out_vddo */
+static int update_drv_trim(struct i2c_client *client, int novtt, int chn) /* no Vtt - CMOS, no termination, where it matters */
+{
+	int rc;
+	int out_type, out_vdd,trim=-1;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if (((out_type=get_drv_type(client,chn)))<0) return out_type;
+	if (((out_vdd=get_drv_vdd(client,chn)))<0)   return out_vdd;
+	switch (out_type) {
+	case 1:
+	case 2:
+	case 3:
+		switch (out_vdd){
+		case 0:trim=novtt?0x17:0x04; break;
+		case 1:trim=novtt?0x13:0x0d; break;
+		case 2:trim=novtt?0x17:0x15; break;
+		case 3:trim=0x1f; break;
+		}
+		break;
+	case 4:
+		switch (out_vdd){
+		case 0:trim=0x0f; break;
+		case 1:trim=0x10; break;
+		}
+		break;
+	case 5:
+		switch (out_vdd){
+		case 0:trim=0x08; break;
+		case 1:trim=0x09; break;
+		}
+		break;
+	case 6:
+		switch (out_vdd){
+		case 0:trim=0x03; break;
+		case 1:
+		case 2:trim=0x04; break;
+		}
+		break;
+	case 7:
+		switch (out_vdd){
+		case 0:
+		case 1:
+		case 2:trim=0x07; break;
+		}
+		break;
+	}
+	if (trim<0){
+		dev_err(&client->dev, "Invalid combination of output type (%d) and voltage (%d)\n",out_type,out_vdd);
+		return - EINVAL;
+	}
+	return write_multireg64(client, trim, awe_drv_trim[chn]);
+}
+/* uses out_type, out_vddo and out_trim */
+static char * get_drv_txt(struct i2c_client *client, int chn)
+{
+	int rc;
+	int out_type, out_vdd,out_trim=-1;
+	if (((rc=_verify_output_channel(client,chn)))<0) return NULL;
+	if (((out_type=get_drv_type(client,chn)))<0) return NULL;
+	if (((out_vdd=get_drv_vdd(client,chn)))<0)  return NULL;
+	if (((out_vdd=get_drv_trim(client,chn)))<0)  return NULL;
+	switch (out_type) {
+	case 1:
+		switch (out_vdd){
+		case 0:return (out_trim & 0x10)?"3.3V CMOS, A & B":"3.3V SSTL, A only";
+		case 1:return (out_trim & 0x10)?"2.5V CMOS, A & B":"2.5V SSTL, A only";
+		case 2:return (out_trim & 0x02)?"1.8V SSTL, A & B":"1.8V CMOS, A only";
+		case 3:return "1.5V HSTL, A only";
+		}
+		break;
+	case 2:
+		switch (out_vdd){
+		case 0:return (out_trim & 0x10)?"3.3V CMOS, A & B":"3.3V SSTL, B only";
+		case 1:return (out_trim & 0x10)?"2.5V CMOS, A & B":"2.5V SSTL, B only";
+		case 2:return (out_trim & 0x02)?"1.8V SSTL, A & B":"1.8V CMOS, B only";
+		case 3:return "1.5V HSTL, B only";
+		}
+		break;
+	case 3:
+		switch (out_vdd){
+		case 0:return (out_trim & 0x10)?"3.3V CMOS, A & B":"3.3V SSTL, A & B";
+		case 1:return (out_trim & 0x10)?"2.5V CMOS, A & B":"2.5V SSTL, A & B";
+		case 2:return (out_trim & 0x02)?"1.8V SSTL, A & B":"1.8V CMOS, A & B";
+		case 3:return "1.5V HSTL, A & B";
+		}
+		break;
+	case 4:
+		switch (out_vdd){
+		case 0:return "3.3V LVPECL";
+		case 1:return "2.5V LVPECL";
+		}
+		break;
+	case 5:
+		switch (out_vdd){
+		case 0:return "3.3V CML";
+		case 1:return "2.5V CML";
+		}
+		break;
+	case 6:
+		switch (out_vdd){
+		case 0:return "3.3V LVDS";
+		case 1:return "2.5V LVDS";
+		case 2:return "1.8V LVDS";
+		}
+		break;
+	case 7:
+		switch (out_vdd){
+		case 0:return "3.3V HCSL";
+		case 1:return "2.5V HCSL";
+		case 2:return "1.8V HCSL";
+		}
+		break;
+	}
+	dev_err(&client->dev, "Invalid combination of output type (%d) and voltage (%d)\n",out_type,out_vdd);
+	switch (out_vdd){
+	case 0:return "3.3V - invalid type";
+	case 1:return "2.5V - invalid type";
+	case 2:return "1.8V - invalid type";
+	case 3:return "1.5V - invalid type";
+	}
+	return NULL; /* never */
+}
+
+static int set_drv_trim_any(struct i2c_client *client, int trim, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((trim<0) || (trim>31)){
+		dev_err(&client->dev, "Invalid output type %d. Only 0..31 are supported\n",trim);
+		return - EINVAL;
+	}
+	return write_multireg64(client, trim, awe_drv_trim[chn]);
+}
+
+static int set_out_div(struct i2c_client *client, int div, int chn) /*chn =0..3 */
+{
+	int rc;
+	u8 val;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	for (val=0;val<(sizeof(out_div_values)/sizeof(out_div_values[0]));val++) if (out_div_values[val]==div) {
+		if (((rc=write_field (client, val,  awe_rdiv_k[chn] )))<0) return rc;
+		return 0;
+	}
+	dev_err(&client->dev, "Invalid value for output divider: %d\n",div);
+	return - EINVAL;
+}
+
+static int get_out_div(struct i2c_client *client, int chn) /*chn =0..3 */
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if (((rc=read_field(client, awe_rdiv_k[chn])))<0) return rc;
+	if (rc>=(sizeof(out_div_values)/sizeof(out_div_values[0]))){
+		dev_err(&client->dev, "Invalid value for output divider: %d\n",rc);
+		return - EINVAL;
+	}
+	return out_div_values[rc];
+}
+
+static int set_out_div_by_frequency(struct i2c_client *client, u64* out_freq, int chn) /*chn =0..3 */
+{
+	int rc,i,idiv;
+	u64 out_src_freq[3],div, div15, out_src_nom,out_src_denom,out_nom,out_denom;
+	if (((rc=get_output_src_frequency(client, out_src_freq, chn)))<0) return rc;
+	out_src_nom=out_src_freq[0]*out_src_freq[2]+out_src_freq[1];
+	out_src_denom=out_src_freq[2];
+	out_nom=out_freq[0]*out_freq[2]+out_freq[1];
+	out_denom=out_freq[2];
+	if (out_nom==0){
+		dev_err(&client->dev, "Zero output frequency for channel: %d\n",chn);
+		return - EINVAL;
+	}
+	while ((out_src_denom>0x1000) || (((out_src_denom | out_src_nom) &1)==0)){
+		out_src_denom>>=1;
+		out_src_nom>>=  1;
+	}
+	while ((out_denom>0x1000) || (((out_denom | out_nom) &1)==0)){
+		out_denom>>=1;
+		out_nom>>=  1;
+	}
+	out_src_nom*=out_denom;
+	out_src_denom*=out_nom;
+	div=div64_u64(out_src_nom + (out_src_denom>>1), out_src_denom);
+	div15=div+(div>>1);
+	if ((div15<1) || (div15>=64)) {
+		dev_err(&client->dev, "Output divider (%d) out of 1..32 range for output %d \n",(int) div,chn);
+		return - EINVAL;
+	}
+	idiv=(int) div15;
+    for (i=5;i>=0;i++) if ((1<<i) & idiv){
+    	return  set_out_div(client, (1<<i), chn);
+    }
+	return - EINVAL; /* should not happen */
+}
+
+static int get_out_frequency(struct i2c_client *client, u64* out_freq, int chn) /*chn =0..3 */
+{
+	int rc,div;
+	u64 out_src_freq[3];
+	if (((rc=get_output_src_frequency(client, out_src_freq, chn)))<0) return rc;
+	if (((div=get_out_div(client, chn)))<0)return div;
+	out_freq[1]=out_src_freq[0]*out_src_freq[2]+out_src_freq[1];
+	out_freq[2]=out_src_freq[2]*div;
+	out_freq[0]=div64_u64(out_freq[1],out_freq[2]);
+	out_freq[1]-=out_freq[0]*out_freq[2];
+	if (out_freq[1]==0) out_freq[2]=1;
+	while (((out_freq[1] | out_freq[2]) &1) == 0) {
+		out_freq[1] >>= 1;
+		out_freq[2] >>= 1;
+	}
+	return 0;
+}
+static int get_out_source(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_rdiv_in[chn]);
+}
+
+static int set_out_source(struct i2c_client *client, int chn, int src)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if ((src<0) || (src>7)){
+		dev_err(&client->dev, "Invalid source %d. Only 0...7 are supported\n",src);
+		return - EINVAL;
+	}
+	return write_field (client, (u8) src, awe_rdiv_in[chn]);
+}
+
+static s64 get_output_src_frequency(struct i2c_client *client, u64 *out_freq, int chn)
+{
+	int mux;
+	int div=1,rc=0;
+	s64 freq[3]={0,0,1};
+	if (((mux=get_out_source(client,chn)))<0) return mux;
+	switch (mux){
+	case 0:
+		freq[0]= get_p2div_in_frequency(client);
+		break;
+	case 1:
+		freq[0]= get_p1div_in_frequency(client);
+		break;
+	case 2:
+		freq[0]= get_p2div_in_frequency(client);
+		div=get_in_pdiv(client,1);
+		break;
+	case 3:
+		freq[0]= get_p1div_in_frequency(client);
+		div=get_in_pdiv(client,0);
+		break;
+	case 4:
+		freq[0]= get_in_frequency (client,0); /* IN1/IN2, xtal */
+		break;
+	case 5:
+		rc=get_pll_ms_freq(client, freq, 0); /* MS0 output */
+		break;
+	case 6:
+		rc=get_pll_ms_freq(client, freq, chn); /* MS<n> output */
+		break;
+	case 7:
+		freq[0]= 0; /* No clock */
+		break;
+	default:
+		dev_err(&client->dev, "Invalid value for output source mux %d\n",mux);
+		return - EINVAL;
+	}
+	if (rc<0)       return rc;
+	if (freq[0]<0) return freq[0];
+	if (div<0)  return div;
+	out_freq[1]=freq[0]+freq[1]*freq[2];
+	out_freq[2]=freq[2]*div;
+	out_freq[0]=div64_u64(out_freq[1],out_freq[2]);
+	out_freq[1]-=out_freq[0]*out_freq[2];
+	if (out_freq[1]==0) out_freq[2]=1;
+	while (((out_freq[1] | out_freq[2]) &1) == 0) {
+		out_freq[1] >>= 1;
+		out_freq[2] >>= 1;
+	}
+	return 0;
+}
+
+/* -----------PLL section--------------------------- */
+static int set_pll_paremeters(struct i2c_client *client)
+{
+	int rc;
+	s64 pll_in_freq;
+	u64 pll_out_freq[3];
+	s64 K,Q,kphi_nom,kphi_denom,fvco_mhz, fpfd_mhz;
+	int rsel,bwsel,vco_gain,pll_kphi,mscal,ms_pec;
+	if (((pll_in_freq=get_pll_in_frequency(client)))<0) return (int) pll_in_freq;
+	if (((rc=get_pll_freq(client,pll_out_freq)))<0) return rc;
+	fpfd_mhz = div64_u64(pll_in_freq,1000000ll);
+	fvco_mhz = div64_u64(pll_out_freq[0],1000000ll);
+	if (fpfd_mhz>=15){
+		K=925;
+		rsel=0;
+		bwsel=0;
+	} else if (fpfd_mhz>=8){
+		K=325;
+		rsel=1;
+		bwsel=1;
+	} else {
+		K=185;
+		rsel=3;
+		bwsel=2;
+	}
+	if (fvco_mhz>2425){
+		Q=3;
+		vco_gain=0;
+	} else {
+		Q=4;
+		vco_gain=1;
+	}
+	kphi_nom=  K*2500LL*2500LL*2500LL;
+	kphi_denom=533LL*Q*fpfd_mhz*fvco_mhz*fvco_mhz;
+	pll_kphi=(int) div64_u64(kphi_nom + (kphi_denom>>1),kphi_denom);
+	if ((pll_kphi<1) || (pll_kphi>127)) {
+		dev_err(&client->dev, "Calculated PLL_KPHI does not fit 1<=%d<=127\n",pll_kphi);
+		if (pll_kphi<1) pll_kphi=1;
+		else if (pll_kphi>127) pll_kphi=127;
+	}
+	mscal = (int) div64_u64(2067000-667*fvco_mhz+50000,100000ll);
+	if ((mscal<0) || (mscal>63)) {
+		dev_err(&client->dev, "Calculated MSCAL does not fit 0<=%d<=63\n",mscal);
+		if (mscal<0) mscal=0;
+		else if (mscal>63) mscal=63;
+	}
+	ms_pec = 7;
+	dev_dbg(&client->dev, "Calculated values: PLL_KPHI=%d K=%lld RSEL=%d BWSEL=%d VCO_GAIN=%d MSCAL=%d MS_PEC=%d\n",
+			pll_kphi, K, rsel, bwsel, vco_gain, mscal, ms_pec);
+	/* setting actual registers */
+	if (((rc=write_field(client, (u8) pll_kphi, AWE_PLL_KPHI)))<0) return rc;
+	if (((rc=write_field(client, (u8) (((vco_gain & 7)<<4) | ((rsel & 3)<<2) | (bwsel & 3)),
+			AWE_VCO_GAIN_RSEL_BWSEL)))<0) return rc;
+	if (((rc=write_field(client, (u8) mscal,  AWE_MSCAL )))<0) return rc;
+	if (((rc=write_field(client, (u8) ms_pec, AWE_MS_PEC)))<0) return rc;
+	return 0;
+}
+
+static int set_misc_registers(struct i2c_client *client)
+{
+	/* ST52238 Reference Manual R1.2 p.28 */
+	int rc;
+	if (((rc=write_field(client, 0x5,  AWE_MISC_47 )))<0) return rc;
+	if (((rc=write_field(client, 0x1,  AWE_MISC_106 )))<0) return rc;
+	if (((rc=write_field(client, 0x1,  AWE_MISC_116 )))<0) return rc;
+	if (((rc=write_field(client, 0x1,  AWE_MISC_42 )))<0) return rc;
+	if (((rc=write_field(client, 0x0,  AWE_MISC_06A )))<0) return rc;
+	if (((rc=write_field(client, 0x0,  AWE_MISC_06B )))<0) return rc;
+	if (((rc=write_field(client, 0x0,  AWE_MISC_28 )))<0) return rc;
+	return 0;
+}
+
+
+
+/* -----------MultiSynth section--------------------------- */
+static u32 awe_msx[5][3][5]=
+	{{{AWE_MS0_P1_07_00, AWE_MS0_P1_15_08, AWE_MS0_P1_17_16, 0, 0},
+	  {AWE_MS0_P2_05_00, AWE_MS0_P2_13_06, AWE_MS0_P2_21_14, AWE_MS0_P2_29_22, 0},
+	  {AWE_MS0_P3_07_00, AWE_MS0_P3_15_08, AWE_MS0_P3_23_16, AWE_MS0_P3_29_24, 0}},
+	 {{AWE_MS1_P1_07_00, AWE_MS1_P1_15_08, AWE_MS1_P1_17_16, 0, 0},
+	  {AWE_MS1_P2_05_00, AWE_MS1_P2_13_06, AWE_MS1_P2_21_14, AWE_MS1_P2_29_22, 0},
+	  {AWE_MS1_P3_07_00, AWE_MS1_P3_15_08, AWE_MS1_P3_23_16, AWE_MS1_P3_29_24, 0}},
+	 {{AWE_MS2_P1_07_00, AWE_MS2_P1_15_08, AWE_MS2_P1_17_16, 0, 0},
+	  {AWE_MS2_P2_05_00, AWE_MS2_P2_13_06, AWE_MS2_P2_21_14, AWE_MS2_P2_29_22, 0},
+	  {AWE_MS2_P3_07_00, AWE_MS2_P3_15_08, AWE_MS2_P3_23_16, AWE_MS2_P3_29_24, 0}},
+	 {{AWE_MS3_P1_07_00, AWE_MS3_P1_15_08, AWE_MS3_P1_17_16, 0, 0},
+	  {AWE_MS3_P2_05_00, AWE_MS3_P2_13_06, AWE_MS3_P2_21_14, AWE_MS3_P2_29_22, 0},
+	  {AWE_MS3_P3_07_00, AWE_MS3_P3_15_08, AWE_MS3_P3_23_16, AWE_MS3_P3_29_24, 0}},
+	 {{AWE_MSN_P1_07_00, AWE_MSN_P1_15_08, AWE_MSN_P1_17_16, 0, 0},
+	  {AWE_MSN_P2_05_00, AWE_MSN_P2_13_06, AWE_MSN_P2_21_14, AWE_MSN_P2_29_22, 0},
+	  {AWE_MSN_P3_07_00, AWE_MSN_P3_15_08, AWE_MSN_P3_23_16, AWE_MSN_P3_29_24, 0}}};
+
+static const u32 awe_ms_powerdown[]={AWE_MS0_PDN, AWE_MS1_PDN, AWE_MS2_PDN, AWE_MS3_PDN};
+static int get_ms_powerdown(struct i2c_client *client, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	return read_field (client, awe_drv_powerdown[chn]);
+}
+
+static int set_ms_powerdown(struct i2c_client *client, int typ, int chn)
+{
+	int rc;
+	if (((rc=_verify_output_channel(client,chn)))<0) return rc;
+	if (typ) typ=1;
+	return write_field (client, (u8) typ, awe_drv_powerdown[chn]);
+}
+
+static int ms_to_p123(u64* ms,u32 * p123)
+{
+	/*
+	 *  a=ms[0],b=ms[1],c=ms[2] ms~=a+b/c
+	 * p1=floor(((a*c+b)*128)/c -512)
+	 * p2=mod((b*128),c)
+	 * p3=c
+	 */
+	u64 d;
+	u64 ms_denom=ms[2], ms_nom=ms[1], ms_int=ms[0];
+	while ((ms_denom >= (1<<30))| (((ms_denom | ms_nom) &1) == 0)) {
+		ms_denom >>= 1;
+		ms_nom >>= 1;
+	}
+	if ((ms_nom==0) || (ms_denom==0)){
+		ms_denom = 1;
+		ms_nom = 0;
+	}
+	d= (ms_int * ms_denom + ms_nom)<<7;
+	p123[0]= (u32) (div64_u64(d,ms_denom) -512);
+	d=div64_u64((ms_nom<<7),ms_denom);
+	p123[1]= (u32) ((ms_nom<<7)-d*ms_denom);
+	p123[2]=ms_denom;
+	return 0;
+}
+static int p123_to_ms(u64* ms,u32 * p123)
+{
+	/* a=ms[0],b=ms[1],c=ms[2] ms~=a+b/c
+	 * p1=floor(((a*c+b)*128)/c -512)
+	 * p2=mod((b*128),c)
+	 * p3=c
+	 * ---
+	 * b*128=k*c +p2; k<128, p2<c
+	 * p1=floor(((a*c+b)*128)/c -512)=a*128 + floor((b*128)/c) -512 = a*128+ k -512
+	 * k=mod (p1,128) =p1 & 0x7f
+	 * c= p3
+	 * b= (k*c + p2)/128= ((p1 & 0x7f)*p3 + p2) >>7
+	 * a= (p1+512)>>7=(p1>>7)+4
+	 *
+	 */
+	ms[2]=p123[2]; /* c= p3 */
+	ms[1]=(ms[2]*(p123[0] & 0x7f) + p123[1]) >>7; /* b= (c*(p1 & 0x7f) + p2) >>7 */
+	ms[0]=(p123[0]>>7)+4; /* a= (p1>>7)+4 */
+	return 0;
+}
+
+
+static int get_ms_p123(struct i2c_client *client,u32 * p123, int chn) /* chn 0,1,2,3,4 (4 - msn) */
+{
+	int i;
+	s64 rc;
+	if ((chn<0) || (chn>4)){
+		dev_err(&client->dev, "Invalid channel %d. Only 0,1,2,3 and 4 (for MSN) are supported\n",chn);
+		return - EINVAL;
+	}
+	for (i=0;i<3;i++){
+		if (((rc=read_multireg64 (client,  awe_msx[chn][i])))<0) return (int) rc;
+		p123[i]= (u32) rc;
+	}
+	return 0;
+}
+static int set_ms_p123(struct i2c_client *client,u32 * p123, int chn) /* chn 0,1,2,3,4 (4 - msn) */
+{
+	int i,rc;
+	if ((chn<0) || (chn>4)){
+		dev_err(&client->dev, "Invalid channel %d. Only 0,1,2,3 and 4 (for MSN) are supported\n",chn);
+		return - EINVAL;
+	}
+	for (i=0;i<3;i++){
+		if (((rc=write_multireg64(client, (u64) p123[i], awe_msx[chn][i])))<0) return rc;
+	}
+	return 0;
+}
+
+/* Setting PLL frequency in 3 ways:
+ * 1 - specified directly, allow fractional MSN
+ * 2 - specified directly, integer MSN
+ * 3 - specified by output frequency, allow fractional MSN (use PPL frequency closest to the middle)
+ * 4 - specified by output frequency, integer MSN
+ */
+static int set_pll_freq(struct i2c_client *client, u64 *vco_freq, int int_div)
+{
+	s64 pll_in_freq, pll_in_freq_scaled,pll_out_freq_scaled,d;
+	u32 msn_p123[3];
+    u64 msn[]={0,0,1};
+    s64 vco_int=vco_freq[0],vco_nom=vco_freq[1],vco_denom=vco_freq[2];
+    if ((vco_nom==0) || (vco_denom==0)){
+    	vco_nom=0;
+    	vco_denom=1;
+    }
+    if (vco_nom>=vco_denom){ /* normalize */
+		d=div64_u64(vco_nom,vco_denom);
+		vco_int+=d;
+		vco_nom-=d*vco_denom;
+    }
+	if (vco_int < FVCOMIN){
+		dev_err(&client->dev, "Specified PLL frequency is too low: %llu < %llu\n",vco_int, FVCOMIN);
+		return - EINVAL;
+	}
+	if (vco_int > FVCOMAX){
+		dev_err(&client->dev, "Specified PLL frequency is too high: %llu > %llu\n",vco_int, FVCOMAX);
+		return - EINVAL;
+	}
+
+	pll_in_freq=get_pll_in_frequency(client);
+	if (pll_in_freq<0) return (int) pll_in_freq;
+	pll_in_freq_scaled=pll_in_freq*vco_denom;
+//	pll_out_freq_scaled=pll_out_freq*vco_denom;
+	pll_out_freq_scaled=vco_int*vco_denom+vco_nom;
+	msn[0]=div64_u64(pll_out_freq_scaled,pll_in_freq_scaled);
+	msn[1]=pll_out_freq_scaled-pll_in_freq_scaled*msn[0];
+	msn[2]=pll_in_freq_scaled;
+	while (msn[2] >= (1<<30)) { /* trim */
+		msn[2] >>= 1;
+		msn[1] >>= 1;
+	}
+
+	if (msn[0] < MSINT_MIN){
+		dev_err(&client->dev, "Calculated MSN ratio is too low: %llu < %u\n",msn[0], MSINT_MIN);
+		return - EINVAL;
+	}
+	if (msn[0] > MSINT_MAX){
+		dev_err(&client->dev, "Calculated MSN ratio is too high: %llu > %u\n",msn[0], MSINT_MAX);
+		return - EINVAL;
+	}
+	if (int_div){
+		if (msn[1]>=(msn[2]>>1)) msn[0]++; // round
+		msn[1] = 0;
+		msn[2] = 1;
+	}
+	ms_to_p123(msn, msn_p123);
+	return set_ms_p123(client,msn_p123, 4); // MSN
+}
+/* normalizes output */
+static int get_pll_freq(struct i2c_client *client,u64 * pll_freq)
+{
+	int rc;
+	s64 pll_in_freq;
+	u32 p123[3];
+	s64 d;
+	pll_in_freq=get_pll_in_frequency(client);
+	if (pll_in_freq<=0) return (int) pll_in_freq;
+	if (((rc=get_ms_p123(client,p123,4)))<0) return rc; /* channel4 - MSN */
+	p123_to_ms(pll_freq,p123);
+	if (pll_freq[2]<=0) return -EINVAL; /* 0 denominator */
+	pll_freq[0]*=pll_in_freq;
+	pll_freq[1]*=pll_in_freq;
+	if (pll_freq[1]>=pll_freq[0]){ /* normalize */
+		d=div64_u64(pll_freq[1],pll_freq[2]);
+		pll_freq[0]+=d;
+		pll_freq[1]-=d*pll_freq[2];
+	}
+	return 0;
+}
+
+
+
+/*
+ *  Calculate pll output frequency to match specified output frequency
+ *  out_freq as int,nom,denom
+ */
+static int set_pll_freq_by_out(struct i2c_client *client, u64 *out_freq, int int_msn_div)
+{
+	/* use r-divider if the output frequency is too low (less than 5 MHz) */
+	u64 out_int=out_freq[0],out_nom=out_freq[1],out_denom=out_freq[2],
+			pll_out_freq[3], scaled_max,scaled_min,d;
+	s64 pll_freq_scaled, out_freq_scaled,err,best_err=-1,center_scaled,center_diff,best_center_diff,
+			out_div,pll_in_freq,in_div,best_in_div, pll_in_freq_scaled,synth_out_scaled;
+	int r_div=1;
+	if (out_denom==0){
+		dev_err(&client->dev, "Denominator should not be 0 in %lld+%lld/%lld\n",
+				out_int,out_nom,out_denom);
+		return -EINVAL;
+	}
+	if (out_nom>=out_denom){ /* normalize */
+		d=div64_u64(out_nom,out_denom);
+		out_int+=d;
+		out_nom-=d*out_denom;
+	}
+	if (out_int<(FVCOMAX/MSINT_MAX)){
+		while ((r_div < 32) && (out_int<(FVCOMAX/MSINT_MAX))){
+			out_int<<=1;
+			out_nom<<=1;
+			r_div<<=1;
+			if (out_nom>out_denom) {
+				out_int++;
+				out_nom-=out_denom;
+			}
+
+		}
+		if (out_int<(FVCOMAX/MSINT_MAX)){
+			dev_err(&client->dev, "Specified output frequency is too low: %lld < %lld\n",
+					out_freq[0], FVCOMAX/MSINT_MAX/32);
+			return -EINVAL;
+		}
+	}
+	dev_dbg(&client->dev, "Output divider by %u, Output frequency before divider: %llu+%llu/%llu Hz\n",
+			r_div,out_int, out_nom,out_denom);
+
+	out_freq_scaled=out_int*out_denom+out_nom;
+	scaled_max=FVCOMAX*out_denom;
+	scaled_min=FVCOMIN*out_denom;
+	if (int_msn_div==0){
+		out_div=div64_u64( (FVCOMAX+FVCOMIN/2)*out_denom+(out_freq_scaled>>1),out_freq_scaled);
+		if ((out_div==7) || (out_div==5) || (out_div==3)){
+			if (out_freq_scaled*(out_div+1)<scaled_max){
+				out_div++;
+			} else if ((out_div>4) && (out_freq_scaled*(out_div-1)>scaled_min)){
+				out_div--;
+			} else {
+				out_div=0;
+			}
+		}
+		if ((out_div<4) || (out_div > MSINT_MAX) ||
+		    (out_freq_scaled*out_div < scaled_min) ||
+		    (out_freq_scaled*out_div > scaled_max)){
+			dev_err(&client->dev, "Can not find suitable divisor for output frequency %lld+%lld/%lld Hz\n",
+					out_int, out_nom,out_denom);
+			return -EINVAL;
+		}
+		pll_out_freq[0]=div64_u64(out_freq_scaled*out_div,out_denom);
+		pll_out_freq[1]=(out_freq_scaled*out_div)-pll_out_freq[0]*out_denom;
+		pll_out_freq[2]=out_denom;
+		dev_dbg(&client->dev, "PLL output divider by %llu, pll frequency: %llu+%llu/%llu Hz\n",
+				out_div,pll_out_freq[0],pll_out_freq[1],pll_out_freq[2]);
+		return set_pll_freq(client, pll_out_freq, 0);
+	} else { /* if (int_msn_div==0), find the best pair of integer coefficients, try closest to the center, if possible */
+		pll_in_freq=get_pll_in_frequency(client);
+		pll_in_freq_scaled=pll_in_freq*out_denom;
+		center_scaled=((FVCOMAX+FVCOMIN)>>1)*out_denom;
+		if (pll_in_freq<0) return (int) pll_in_freq;
+		best_in_div=0;
+		for (out_div=4;out_div<=MSINT_MAX;out_div++) if ((out_div!=5) && (out_div!=7)){
+			pll_freq_scaled=out_freq_scaled*out_div; /* here scaled by denominator */
+			if ((pll_freq_scaled>=scaled_min) && (pll_freq_scaled<=scaled_max)) {
+				in_div=div64_u64(pll_freq_scaled+(pll_in_freq_scaled>>1),pll_in_freq_scaled); // round
+				d=pll_in_freq_scaled*in_div; /* actual pll frequency scaled by out_denom */
+				synth_out_scaled=div64_u64(d + (out_div>>1),out_div);
+				center_diff=d-center_scaled;
+				if (center_diff<0) center_diff=-center_diff;
+				err=synth_out_scaled-out_freq_scaled;
+				if (err<0) err=-err;
+				if ((best_in_div==0) || (err < best_err) || ((err == best_err) && (center_diff<best_center_diff))){
+					dev_dbg(&client->dev, "synth_out_scaled: %lld center_scaled: %lld out_freq_scaled:%lld err: %lld (%lld) center_diff:%lld(%lld)\n",
+							synth_out_scaled, center_scaled, out_freq_scaled,err,best_err,center_diff,best_center_diff);
+					best_err=err;
+					best_in_div=in_div;
+					best_center_diff=center_diff;
+				}
+			}
+		}
+		if (best_in_div==0){
+			dev_err(&client->dev, "Failed to find suitable integer coefficients for pll input %lld Hz\n",
+					pll_in_freq);
+
+		}
+		pll_out_freq[0]=div64_u64(pll_in_freq_scaled*best_in_div,out_denom);
+		pll_out_freq[1]=(pll_in_freq_scaled*best_in_div)-pll_out_freq[0]*out_denom;
+		pll_out_freq[2]=out_denom;
+		dev_dbg(&client->dev, "PLL output frequency: %llu+%llu/%llu Hz, MS input divider: %lld, MS output divider: %lld\n",
+				pll_out_freq[0],pll_out_freq[1],pll_out_freq[2], best_in_div, out_div);
+		return set_pll_freq(client, pll_out_freq, 1); /* integer result */
+	}
+}
+
+static int get_pll_ms_freq(struct i2c_client *client, u64 *out_freq, int chn)
+{
+	int rc;
+	u64 pll_out_freq[3], ms[3], pll_freq_scaled, ms_scaled;
+	u32 p123[3];
+	if (((rc=get_pll_freq(client,pll_out_freq)))<0) return rc;
+	/* trim PLL frequency fraction */
+	while (pll_out_freq[2]>=0x1000){
+		pll_out_freq[1] >>= 1;
+		pll_out_freq[2] >>= 1;
+	}
+	pll_freq_scaled=pll_out_freq[0]*pll_out_freq[2]+pll_out_freq[1];
+
+	if (((rc=get_ms_p123(client,p123, chn)))<0) return rc; /* includes invalid chn */
+	p123_to_ms(ms,p123);
+	/* trim MS divisor fraction */
+	while (ms[2]>=0x1000){
+		ms[1] >>= 1;
+		ms[2] >>= 1;
+	}
+	ms_scaled=ms[0]*ms[2]+ms[1];
+	out_freq[1]=pll_freq_scaled*ms[2];
+	out_freq[2]=ms[0]*pll_out_freq[2];
+	out_freq[0]=div64_u64(out_freq[1],out_freq[2]);
+	out_freq[1]-=out_freq[0]*out_freq[2];
+	if (out_freq[1]==0) out_freq[2]=1;
+	dev_dbg(&client->dev, "MS%d output frequency: %llu+%llu/%llu Hz\n",chn,out_freq[0],out_freq[1],out_freq[2]);
+	return 0;
+}
+
+/*
+ *  Adjust MultiSynth divisor (MS0..MS3) for specified output frequency
+ *  MSN, input frequency should be already set
+ *  out_freq as int,nom,denom
+ */
+static int set_pll_ms_by_out(struct i2c_client *client, u64 *out_freq, int chn, int int_div)
+{
+	/* use r-divider if the output frequency is too low (less than 5 MHz) */
+	u64 out_int=out_freq[0],out_nom=out_freq[1],out_denom=out_freq[2],
+			pll_out_freq[3],d;
+	s64 pll_freq_scaled, out_freq_scaled;
+	u64 ms[3];
+	u32 p123[3];
+	int r_div=1,rc;
+	if (out_denom==0){
+		dev_err(&client->dev, "Denominator should not be 0 in %lld+%lld/%lld\n",
+				out_int,out_nom,out_denom);
+		return -EINVAL;
+	}
+	if (out_nom>=out_denom){ /* normalize */
+		d=div64_u64(out_nom,out_denom);
+		out_int+=d;
+		out_nom-=d*out_denom;
+	}
+	if (out_nom==0){
+		out_denom=1;
+	}
+	if (out_int<(FVCOMAX/MSINT_MAX)){
+		while ((r_div < 32) && (out_int<(FVCOMAX/MSINT_MAX))){
+			out_int<<=1;
+			out_nom<<=1;
+			r_div<<=1;
+			if (out_nom>out_denom) {
+				out_int++;
+				out_nom-=out_denom;
+			}
+
+		}
+		if (out_int<(FVCOMAX/MSINT_MAX)){
+			dev_err(&client->dev, "Specified output frequency is too low: %lld < %lld\n",
+					out_freq[0], FVCOMAX/MSINT_MAX/32);
+			return -EINVAL;
+		}
+	}
+	dev_dbg(&client->dev, "Output divider by %u, Output frequency before divider: %llu+%llu/%llu Hz\n",
+			r_div,out_int, out_nom,out_denom);
+	/* trim output frequency fraction */
+	while (out_denom>=0x1000){
+		out_nom >>= 1;
+		out_denom >>= 1;
+	}
+	out_freq_scaled=out_int*out_denom+out_nom;
+	if (((rc=get_pll_freq(client,pll_out_freq)))<0) return rc;
+	/* trim PLL frequency fraction */
+	while (pll_out_freq[2]>=0x1000){
+		pll_out_freq[1] >>= 1;
+		pll_out_freq[2] >>= 1;
+	}
+	pll_freq_scaled=pll_out_freq[0]*pll_out_freq[2]+pll_out_freq[1];
+	ms[1]=pll_freq_scaled*out_denom;
+	ms[2]=out_freq_scaled*pll_out_freq[2];
+	ms[0]=div64_u64(ms[1],ms[2]);
+	ms[1]-=ms[0]*ms[2];
+	if (int_div){
+		if (ms[1]>(ms[2]>>1)) ms[0]++;
+		ms[1]=0;
+		ms[2]=1;
+	}
+	dev_dbg(&client->dev, "MS%d divider: %llu+%llu/%llu\n",chn,ms[0],ms[1],ms[2]);
+	/* set up registers */
+	ms_to_p123(ms,p123);
+	if (((rc=set_ms_p123(client,p123, chn)))<0) return rc;
+	return 0;
+}
+
+/* ----------- Input section ----------------- */
+
+static s64 get_pll_in_frequency(struct i2c_client *client)
+{
+	int mux;
+	int div=1;
+	s64 freq;
+	if (((mux=get_in_pfd_ref_fb(client,0)))<0) return mux;
+	switch (mux){
+	case 0:
+		freq= get_p1div_in_frequency(client);
+		break;
+	case 1:
+		freq= get_p2div_in_frequency(client);
+		break;
+	case 2:
+		freq= get_p1div_in_frequency(client);
+		div=get_in_pdiv(client,0);
+		break;
+	case 3:
+		freq= get_p2div_in_frequency(client);
+		div=get_in_pdiv(client,1);
+		break;
+	case 4:
+		freq= get_in_frequency (client,0); /* IN1/IN2, xtal */
+		break;
+	case 5:
+		freq= 0; /* No clock */
+		break;
+	default:
+		dev_err(&client->dev, "Invalid value for PLL input multiplexer %d\n",mux);
+		return - EINVAL;
+	}
+	if (freq<0) return freq;
+	if (div<0)  return div;
+	/* TODO - make it fractional? */
+	return div64_u64(freq,div);
+}
+static s64 get_pll_fb_frequency(struct i2c_client *client)
+{
+	int mux;
+	int div=1;
+	s64 freq;
+	if (((mux=get_in_pfd_ref_fb(client,1)))<0) return mux;
+	switch (mux){
+	case 0:
+		freq= get_p2div_in_frequency(client);
+		break;
+	case 1:
+		freq= get_p1div_in_frequency(client);
+		break;
+	case 2:
+		freq= get_p2div_in_frequency(client);
+		div=get_in_pdiv(client,1);
+		break;
+	case 3:
+		freq= get_p1div_in_frequency(client);
+		div=get_in_pdiv(client,0);
+		break;
+/*	case 4: */
+	case 5:
+		freq= 0; /* No clock */
+		break;
+	default:
+		dev_err(&client->dev, "Invalid value for PLL feedback multiplexer %d\n",mux);
+		return - EINVAL;
+	}
+	if (freq<0) return freq;
+	if (div<0)  return div;
+	/* TODO - make it fractional? */
+	return div64_u64(freq,div);
+}
+
+static s64 get_p1div_in_frequency(struct i2c_client *client)
+{
+	int mux;
+	if (((mux=   get_in_mux(client)))<0) return mux;
+	switch (mux){
+	case 0: return get_in_frequency (client,0); /* IN1/IN2 */
+	case 1: return get_in_frequency (client,1); /* IN3 */
+	case 2: return get_in_frequency (client,0); /* IN1/IN2 - xtal*/
+	default:
+		dev_err(&client->dev, "Invalid value for input multiplexer %d\n",mux);
+		return - EINVAL;
+	}
+}
+static s64 get_p2div_in_frequency(struct i2c_client *client)
+{
+	int mux;
+	if (((mux=   get_fb_mux(client)))<0) return mux;
+	switch (mux){
+	case 0: return get_in_frequency (client,3); /* IN5/IN6 */
+	case 1: return get_in_frequency (client,1); /* IN4 */
+	case 2: return 0; /* no clock */
+	default:
+		dev_err(&client->dev, "Invalid value for input multiplexer %d\n",mux);
+		return - EINVAL;
+	}
+}
+
+static int set_in_mux(struct i2c_client *client, int data)
+{
+	int data1,rc;
+	switch (data) {
+	case 0: data1=0; break;
+	case 1: data1=2; break;
+	case 2: data1=5; break;
+	default:
+		dev_err(&client->dev, "Invalid value for input multiplexer %d\n",data);
+		return - EINVAL;
+	}
+	if (((rc=write_field (client, data,  AWE_IN_MUX )))<0) return rc;
+	if (((rc=write_field (client, data1, AWE_IN_MUX1)))<0) return rc;
+	return 0;
+}
+
+static int get_in_mux(struct i2c_client *client)
+{
+	return read_field(client,AWE_IN_MUX );
+}
+
+static int set_fb_mux(struct i2c_client *client, int data)
+{
+	int data1,rc;
+	switch (data) {
+	case 0: data1=0; break;
+	case 1: data1=1; break;
+	case 2: data1=0; break;
+	default:
+		dev_err(&client->dev, "Invalid value for feedback multiplexer %d\n",data);
+		return - EINVAL;
+	}
+	if (((rc=write_field (client, data,  AWE_FB_MUX )))<0) return rc;
+	if (((rc=write_field (client, data1, AWE_FB_MUX1)))<0) return rc;
+	return 0;
+}
+
+static int get_fb_mux(struct i2c_client *client)
+{
+	return read_field(client,AWE_IN_MUX );
+}
+
+
+
+static const u8 in_div_values[]={1,2,4,8,16,32};
+static int set_in_pdiv(struct i2c_client *client, int div, int chn) /*chn =0,1 */
+{
+	int rc;
+	u8 val;
+	for (val=0;val<(sizeof(in_div_values)/sizeof(in_div_values[0]));val++) if (in_div_values[val]==div) {
+		if (((rc=write_field (client, val,  chn?AWE_P2DIV:AWE_P1DIV )))<0) return rc;
+		return 0;
+	}
+	dev_err(&client->dev, "Invalid value for input divider: %d\n",div);
+	return - EINVAL;
+}
+
+static int get_in_pdiv(struct i2c_client *client, int chn) /*chn =0,1 */
+{
+	int rc;
+	if (((rc=read_field(client, chn?AWE_P2DIV:AWE_P1DIV )))<0) return rc;
+	if (rc>=(sizeof(in_div_values)/sizeof(in_div_values[0]))){
+		dev_err(&client->dev, "Invalid value for input divider: %d\n",rc);
+		return - EINVAL;
+	}
+	return in_div_values[rc];
+}
+
+static int set_in_pfd_ref_fb(struct i2c_client *client, u8 val, int chn) /*chn =0 - ref, 1 - fb*/
+{
+	int rc;
+	if (val>5) {
+		dev_err(&client->dev, "Invalid value for input pfd selector: %d\n", (int) val);
+		return - EINVAL;
+	}
+	if (((rc=write_field (client, val,  chn?AWE_PFD_FB:AWE_PFD_REF )))<0) return rc;
+	return 0;
+}
+
+static int get_in_pfd_ref_fb(struct i2c_client *client, int chn) /*chn =0,1 */
+{
+	return read_field(client, chn?AWE_PFD_FB:AWE_PFD_REF );
+}
+
+static int set_in_frequency(struct i2c_client *client, u64 frequency,int src) /* 0 - 12, 1 - 3, 2 - 4, 3 - 5,6 */
+{
+	int xtal_mode;
+	struct si5338_data_t *clientdata = i2c_get_clientdata(client);
+	if (frequency < INFREQMIN){
+		dev_err(&client->dev, "Input frequency too low: %llu < %llu\n",frequency, INFREQMIN);
+		return - EINVAL;
+	}
+	if (frequency > INFREQMAX){
+		dev_err(&client->dev, "Input frequency too high: %llu > %llu\n",frequency, INFREQMAX);
+		return - EINVAL;
+	}
+	switch (src){
+	case 0:
+		clientdata->input_frequency12=frequency;
+		/* set xtal mode */
+		xtal_mode=0;
+		if (frequency>11000000ll) xtal_mode=1;
+		if (frequency>19000000ll) xtal_mode=2;
+		if (frequency>26000000ll) xtal_mode=3;
+		return write_field (client, xtal_mode, AWE_XTAL_FREQ);
+	case 1:
+		clientdata->input_frequency3=frequency;
+		break;
+	case 2:
+		clientdata->input_frequency4=frequency;
+		break;
+	case 3:
+		clientdata->input_frequency56=frequency;
+		break;
+	default:
+		dev_err(&client->dev, "Invalid source %d only 0 (IN1/2), 1 (IN3), 2 (IN4) and 3 (IN4/IN5) are supported\n",src);
+		return - EINVAL;
+	}
+	return 0;
+}
+static u64 get_in_frequency(struct i2c_client *client, int src)
+{
+	struct si5338_data_t *clientdata = i2c_get_clientdata(client);
+	switch (src){
+	case 0:	return clientdata->input_frequency12;
+	case 1:	return clientdata->input_frequency3;
+	case 2:	return clientdata->input_frequency4;
+	case 3:	return clientdata->input_frequency56;
+	default:
+		dev_err(&client->dev, "Invalid source %d only 0 (IN1/2), 1 (IN3), 2 (IN4) and 3 (IN4/IN5) are supported\n",src);
+		return - EINVAL;
+	}
+}
+
+/* ----------- General ----------------- */
+
+static s64 read_multireg64 (struct i2c_client *client, const u32 * awe)
+{
+	int i,nshift,nbits, full_shift=0;
+	u8 mask;
+	u16 reg;
+	s64 data=0, rc;
+	for (i=0;awe[i]!=0;i++){
+		reg=awe[i]>>8;
+		mask=awe[i]&0xff;
+		if (mask!=0){
+			nshift=0;
+			nbits=1;
+			while (((1<<nshift) & mask)==0) nshift++;
+			while (((1<<(nshift+nbits)) & mask)!=0) nbits++;
+			if (((rc=read_reg(client, reg)))<0) return rc;
+			rc &=  mask;
+			rc >>= nshift;
+			rc <<= full_shift;
+			data |= rc;
+			full_shift+=nbits;
+		}
+	}
+	return data;
+}
+
+
+static int write_multireg64 (struct i2c_client *client, u64 data, const u32 * awe)
+{
+	int i,rc,nshift,nbits;
+	u8 mask,reg_data;
+	u16 reg;
+	for (i=0;awe[i]!=0;i++){
+		reg=awe[i]>>8;
+		mask=awe[i]&0xff;
+		if (mask!=0){
+			nshift=0;
+			nbits=1;
+			while (((1<<nshift) & mask)==0) nshift++;
+			while (((1<<(nshift+nbits)) & mask)!=0) nbits++;
+			reg_data=(data & 0xff) << nshift; /* may have some garbage in high bits, will be cut of by mask */
+			data >>= nbits;
+			if (((rc=write_reg(client, reg, reg_data, mask)))<0) return rc;
+		}
+	}
+	return 0;
+}
+
+static int read_field (struct i2c_client *client, u32 awe)
+{
+	int rc,nshift;
+	u8 mask;
+	u16 reg;
+	reg=awe>>8;
+	mask=awe&0xff;
+	if (mask!=0){
+		nshift=0;
+		while (((1<<nshift) & mask)==0) nshift++;
+		if (((rc=read_reg(client, reg)))<0) return rc;
+		return (rc & mask) >> nshift;
+	}
+	return 0;
+}
+
+
+static int write_field (struct i2c_client *client, u8 data, u32 awe)
+{
+	int rc,nshift;
+	u8 mask,reg_data;
+	u16 reg;
+	reg=awe>>8;
+	mask=awe&0xff;
+	if (mask!=0){
+		nshift=0;
+		while (((1<<nshift) & mask)==0) nshift++;
+		reg_data=(data & 0xff) << nshift;
+		if (((rc=write_reg(client, reg, reg_data, mask)))<0) return rc;
+	}
+	return 0;
+}
+
+
+static int write_adwe(struct i2c_client *client, u32 adwe)
+{
+	u8 we=   adwe & 0xff;
+	u8 data= (adwe>>8) & 0xff;
+	u16 reg=  (adwe>>16) & (0xff | (REG5338_PAGE_MASK << 8)); /* 0x1ff */
+	return write_reg(client, reg, data, we);
+}
+
+static int _write_single_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct si5338_data_t *clientdata = i2c_get_clientdata(client);
+	dev_dbg(&client->dev,"device write: slave=0x%x, reg=0x%x, val=0x%x\n", (int) (client->addr),reg,val);
+	if (clientdata && (reg==REG5338_PAGE)) {
+//		dev_dbg(&client->dev,"changing page: new=0x%x, was=0x%x\n",val & REG5338_PAGE_MASK,clientdata->last_page);
+		clientdata->last_page=val & REG5338_PAGE_MASK;
+	}
+	if (clientdata && (reg<=LAST_REG) ){
+		clientdata->cache[reg].data= val;
+		clientdata->cache[reg].flags |= CACHE_INIT;
+	}
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int write_reg(struct i2c_client *client, u16 reg, u8 val, u8 mask)
+{
+	int rc,page;
+	struct si5338_data_t *clientdata = i2c_get_clientdata(client);
+	if (mask==0) return 0;
+	page=(reg >> 8) & REG5338_PAGE_MASK;
+	if (page != (clientdata->last_page)) { /* set page if needed */
+		if (((rc=_write_single_reg(client, REG5338_PAGE, page)))<0) return rc;
+	}
+//	dev_info(&client->dev,"reg=0x%x, val=0x%x, mask=0x%x\n", (int) reg, (int) val, (int) mask);
+	dev_dbg(&client->dev,"reg=0x%x, val=0x%x, mask=0x%x\n", (int) reg, (int) val, (int) mask);
+	if (mask !=0xff){
+	    if (((rc=read_reg(client, reg & 0xff)))<0) return rc;
+	    val=((val ^ rc) & mask)^ rc;
+	}
+	return  _write_single_reg(client, reg & 0xff, val);
+}
+
+static int read_reg(struct i2c_client *client, u16 reg)
+{
+	int rc,page;
+	struct si5338_data_t *clientdata = i2c_get_clientdata(client);
+	if (clientdata && (reg<=LAST_REG) && (clientdata->cache[reg].flags & CACHE_INIT) && !(clientdata->cache[reg].flags & CACHE_VOLAT)){
+		dev_dbg(&client->dev,"Using cached register: reg=0x%x -> 0x%x\n",reg,(int) clientdata->cache[reg].data);
+		return clientdata->cache[reg].data;
+	}
+	page=(reg >> 8) & REG5338_PAGE_MASK;
+//	dev_dbg(&client->dev,"reading i2c device : slave=0x%x, reg=0x%x page=0x%x, last_page=0x%x\n",(int) (client->addr),reg,page,clientdata->last_page);
+	if (clientdata && (reg!=REG5338_PAGE) && (page != clientdata->last_page)) { /* set page if needed */
+		if (((rc=_write_single_reg(client, REG5338_PAGE, page)))<0) return rc;
+	}
+	rc= i2c_smbus_read_byte_data(client, reg & 0xff);
+	dev_dbg(&client->dev,"reading i2c device : slave=0x%x, reg=0x%x -> 0x%x\n",(int) (client->addr),reg,rc);
+	if (rc<0) return rc;
+	if (clientdata && (reg==REG5338_PAGE)) {
+		clientdata->last_page= rc & REG5338_PAGE_MASK;
+	}
+	if (clientdata && (reg<=LAST_REG)){
+		clientdata->cache[reg].data= (u8) rc;
+		clientdata->cache[reg].flags |= CACHE_INIT;
+	}
+	return rc;
+}
+//#define CACHE_INIT=1;
+//#define CACHE_VOLAT=2;
+
+static void si5338_init_of(struct i2c_client *client)
+{
+//	struct device *dev=&client->dev;
+	const __be32 * config_data;
+	struct device_node *node = client->dev.of_node;
+    int len,i;
+    u16 page_reg;
+    struct si5338_setup_data  {
+    	u8		page;
+    	u8		reg;
+    	u8		data;
+    	u8		mask;
+    };
+    struct si5338_setup_data setup_data;
+    __be32 * setup_data_be32= (__be32 *) &setup_data;
+	if (node) {
+		config_data = of_get_property(client->dev.of_node, "si5338,configuration_data", &len);
+		if (config_data){
+			len /= sizeof(*config_data);
+			dev_dbg(&client->dev,"Read %d values\n",len);
+			dev_info(&client->dev,"Found %d items in 'si5338,configuration_data' in the Device Tree\n",len);
+			for (i=0;i<len;i++){
+				*setup_data_be32=config_data[i];
+				page_reg=setup_data.reg+(setup_data.page<<8);
+			    dev_dbg(&client->dev,"page_reg=0x%03x, data=0x%02x, mask=0x%02x \n",
+			    		(int) page_reg,(int)setup_data.data,(int)setup_data.mask);
+			    if (write_reg(client, page_reg, setup_data.data, setup_data.mask)<0) return;
+			}
+//		} else {
+//			dev_info(&client->dev,"'si5338,configuration_data' not found in the Device Tree\n");
+		}
+		/* input section */
+		config_data = of_get_property(client->dev.of_node, "si5338,in_pfd_ref", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_pfd_ref",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_pfd_ref_fb(client, be32_to_cpup(config_data), 0);
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_pfd_fb", &len);
+		if (config_data && (len>0)){
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_pfd_fb",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_pfd_ref_fb(client, be32_to_cpup(config_data), 1);
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_p1_div", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_p1_div",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_pdiv(client, be32_to_cpup(config_data), 0);
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_p2_div", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_p2_div",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_pdiv(client, be32_to_cpup(config_data), 1);
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_mux", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_mux",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_mux(client, be32_to_cpup(config_data));
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,fb_mux", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,fb_mux",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_fb_mux(client, be32_to_cpup(config_data));
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_frequency12", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_frequency12",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_frequency(client, be32_to_cpup(config_data),0); /* 32 bits are sufficient here */
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_frequency3", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_frequency3",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_frequency(client, be32_to_cpup(config_data),1); /* 32 bits are sufficient here */
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_frequency4", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_frequency4",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_frequency(client, be32_to_cpup(config_data),2); /* 32 bits are sufficient here */
+		}
+		config_data = of_get_property(client->dev.of_node, "si5338,in_frequency56", &len);
+		if (config_data && (len>0)) {
+			dev_info(&client->dev,"Found '%s', value = %d (0x%x)\n","si5338,in_frequency56",(int)(be32_to_cpup(config_data)),(int)(be32_to_cpup(config_data)));
+			set_in_frequency(client, be32_to_cpup(config_data),3); /* 32 bits are sufficient here */
+		}
+	} else {
+		dev_info(&client->dev,"Device tree data not found for %s\n",client->name);
+	}
+}
+
+static int si5338_i2c_probe(struct i2c_client *client,
+				      const struct i2c_device_id *id)
+{
+	int i,rc=0;
+	struct si5338_data_t *clientdata = NULL;
+	/* initialize i2c ... */
+//#define REG5338_DEV_CONFIG2          2
+//#define REG5338_DEV_CONFIG2_MASK  0x3f
+//#define REG5338_DEV_CONFIG2_VAL    38 /* last 2 digits of part number */
+	if (((rc=_write_single_reg(client, REG5338_PAGE,0)))<0) return rc; // did not respond
+	if (((rc=read_reg(client, REG5338_DEV_CONFIG2)))<0) return rc; // did not respond
+	if ((rc & REG5338_DEV_CONFIG2_MASK)!= REG5338_DEV_CONFIG2_VAL){
+		dev_info(&client->dev,
+			 "Chip returned unexpected value from reg %d: %d, expected %d. It is not %s\n",
+			 REG5338_DEV_CONFIG2,rc, REG5338_DEV_CONFIG2_VAL,id->name);
+		return -EIO;
+	}
+
+	dev_info(&client->dev,
+		 "Chip %s is found, driver version %s\n", id->name, DRV_VERSION);
+	clientdata = devm_kzalloc(&client->dev, sizeof(*clientdata), GFP_KERNEL);
+	for (i=0;i<=LAST_REG;i++){
+		clientdata->cache[i].flags=0;
+		clientdata->cache[i].data=0;
+	}
+	i2c_set_clientdata(client, clientdata);
+	if (((rc=read_reg(client, REG5338_PAGE)))<0) return rc; // will set clientdata->last_page
+	si5338_sysfs_register(&client->dev);
+	mutex_init(&clientdata->lock);
+
+	clientdata->input_frequency12=0;
+	clientdata->input_frequency3=0;
+	clientdata->input_frequency4=0;
+	clientdata->input_frequency56=0;
+	si5338_init_of(client);
+	return 0;
+}
+
+
+static int si5338_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+static struct i2c_driver si5338_i2c_driver = {
+	.driver = {
+		.name	= "si5338",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= si5338_i2c_probe,
+	.remove		= si5338_i2c_remove,
+	.id_table	= si5338_id,
+};
+module_i2c_driver(si5338_i2c_driver);
+MODULE_DEVICE_TABLE(i2c, si5338_id);
+MODULE_AUTHOR("Andrey Filippov  <andrey@elphel.com>");
+MODULE_DESCRIPTION("SI5338 I2C bus driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("i2c:si5338");
