Index: git/drivers/net/ethernet/xilinx/xilinx_emacps.c
===================================================================
--- git.orig/drivers/net/ethernet/xilinx/xilinx_emacps.c	2013-11-23 16:44:54.262025863 -0700
+++ git/drivers/net/ethernet/xilinx/xilinx_emacps.c	2013-11-23 00:04:25.000000000 -0700
@@ -468,6 +468,11 @@
 							second */
 #endif
 
+/* Elphel */
+#define AT803X_PHY_ID		0x004dd072 /*Particular one, AR8035 but we'll use a broad mask */
+#define AT803X_PHY_ID_MASK	0xffffffe0
+
+
 #define xemacps_read(base, reg)						\
 	__raw_readl(((void __iomem *)(base)) + (reg))
 #define xemacps_write(base, reg, val)					\
@@ -566,9 +571,18 @@
 static int xemacps_mdio_read(struct mii_bus *bus, int mii_id, int phyreg)
 {
 	struct net_local *lp = bus->priv;
-	u32 regval;
+	u32 regval,oldregval;
 	int value;
 	volatile u32 ipisr;
+	/* check/wait for idle */
+	if ((xemacps_read(lp->baseaddr, XEMACPS_NWSR_OFFSET) &
+	  XEMACPS_NWSR_MDIOIDLE_MASK)==0){
+	    oldregval = xemacps_read(lp->baseaddr, XEMACPS_PHYMNTNC_OFFSET);
+	  	       dev_warn(&lp->pdev->dev," ********* %s:%d Should not happen (add spinlock if it does) - MDIO is NOT IDLE, shift register value=0x%08x\n",
+	  	    		   __func__,__LINE__,(int) value);
+	  	       while ((xemacps_read(lp->baseaddr, XEMACPS_NWSR_OFFSET) &
+	  	    		  XEMACPS_NWSR_MDIOIDLE_MASK)==0); /* just wait */
+	}
 
 	regval  = XEMACPS_PHYMNTNC_OP_MASK;
 	regval |= XEMACPS_PHYMNTNC_OP_R_MASK;
@@ -606,8 +620,17 @@
 	u16 value)
 {
 	struct net_local *lp = bus->priv;
-	u32 regval;
+	u32 regval,oldregval;
 	volatile u32 ipisr;
+	/* check/wait for idle */
+	if ((xemacps_read(lp->baseaddr, XEMACPS_NWSR_OFFSET) &
+	  XEMACPS_NWSR_MDIOIDLE_MASK)==0){
+	    oldregval = xemacps_read(lp->baseaddr, XEMACPS_PHYMNTNC_OFFSET);
+	  	       dev_warn(&lp->pdev->dev," ********* %s:%d Should not happen (add spinlock if it does) - MDIO is NOT IDLE, shift register value=0x%08x\n",
+	  	    		   __func__,__LINE__,(int) value);
+	  	       while ((xemacps_read(lp->baseaddr, XEMACPS_NWSR_OFFSET) &
+	  	    		  XEMACPS_NWSR_MDIOIDLE_MASK)==0); /* just wait */
+	}
 
 	regval  = XEMACPS_PHYMNTNC_OP_MASK;
 	regval |= XEMACPS_PHYMNTNC_OP_W_MASK;
@@ -738,6 +761,50 @@
 	}
 }
 
+/* http://www.spinics.net/lists/devicetree/msg06322.html */
+static int ar8035_phy_fixup(struct phy_device *dev)
+{
+	u16 val;
+	struct net_local *lp = dev->bus->priv;
+	dev_dbg(&lp->pdev->dev,"fixup start");
+
+	/* Ar803x phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(dev, 0xd, 0x3);
+	phy_write(dev, 0xe, 0x805d);
+	phy_write(dev, 0xd, 0x4003);
+
+	val = phy_read(dev, 0xe);
+	phy_write(dev, 0xe, val & ~(1 << 8));
+	/*Enable if needed */
+#if 0
+	/* To enable AR8031 output a 125MHz clk from CLK_25M */
+	phy_write(dev, 0xd, 0x7);
+	phy_write(dev, 0xe, 0x8016);
+	phy_write(dev, 0xd, 0x4007);
+
+	val = phy_read(dev, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(dev, 0xe, val);
+#endif
+/* Next one what is really needed for Elphel 393 */
+	/* introduce tx clock delay */
+	phy_write(dev, 0x1d, 0x5);
+	val = phy_read(dev, 0x1e);
+	val |= 0x0100;
+	phy_write(dev, 0x1e, val);
+
+	/*check phy power*/
+	val = phy_read(dev, 0x0);
+	if (val & BMCR_PDOWN)
+		phy_write(dev, 0x0, val & ~BMCR_PDOWN);
+	dev_dbg(&lp->pdev->dev,"fixup end");
+	return 0;
+}
+
+
 static int xemacps_clk_notifier_cb(struct notifier_block *nb, unsigned long
 		event, void *data)
 {
@@ -840,7 +907,7 @@
 	struct resource res;
 	struct device_node *np = of_get_parent(lp->phy_node);
 	struct device_node *npp;
-
+    phy_register_fixup_for_uid(AT803X_PHY_ID,  AT803X_PHY_ID_MASK,  ar8035_phy_fixup);
 	lp->mii_bus = mdiobus_alloc();
 	if (lp->mii_bus == NULL) {
 		rc = -ENOMEM;
